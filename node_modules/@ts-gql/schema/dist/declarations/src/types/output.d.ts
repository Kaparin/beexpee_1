import { GraphQLFieldExtensions, GraphQLList, GraphQLObjectType, GraphQLResolveInfo, GraphQLUnionType } from "graphql/type/definition";
import { Arg, InferValueFromArgs, InputType, ScalarType, EnumType } from "./types-that-do-not-use-context";
declare type OutputListType<Of extends OutputTypes> = {
    kind: "list";
    of: Of;
    graphQLType: GraphQLList<Of["graphQLType"]>;
};
declare type OutputNonNullType<Of extends OutputTypeExcludingNonNull> = {
    kind: "non-null";
    of: Of;
    graphQLType: GraphQLList<Of["graphQLType"]>;
};
export declare type OutputTypeExcludingNonNull = ScalarType<any> | ObjectType<any, string, any> | UnionType<ObjectType<any, string, any>> | EnumType<any> | OutputListType<any>;
export declare type OutputTypes = OutputTypeExcludingNonNull | OutputNonNullType<any>;
declare type InferValueFromOutputTypeWithoutAddingNull<Type extends OutputTypes> = Type extends ScalarType<infer Value> ? Value : Type extends EnumType<infer Values> ? Values[keyof Values]["value"] : Type extends OutputListType<infer Value> ? InferValueFromOutputType<Value>[] : Type extends ObjectType<infer RootVal, string, any> ? RootVal : Type extends UnionType<ObjectType<infer RootVal, string, any>> ? RootVal : never;
export declare type InferValueFromOutputType<Type extends OutputTypes> = Type extends OutputNonNullType<infer Value> ? InferValueFromOutputTypeWithoutAddingNull<Value> : InferValueFromOutputTypeWithoutAddingNull<Type> | null;
export declare type ObjectType<RootVal, Name extends string, Context> = {
    kind: "object";
    name: Name;
    graphQLType: GraphQLObjectType;
    __context: Context;
    __rootVal: RootVal;
};
declare type MaybePromise<T> = Promise<T> | T;
export declare type OutputFieldResolver<Args extends Record<string, Arg<any>>, OutputType extends OutputTypes, RootVal, Context> = (rootVal: RootVal, args: InferValueFromArgs<Args>, context: Context, info: GraphQLResolveInfo) => MaybePromise<InferValueFromOutputType<OutputType>>;
declare type SomeTypeThatIsntARecordOfArgs = string;
export declare type OutputField<RootVal, Args extends Record<string, Arg<any>>, OutputType extends OutputTypes, Key extends string, Context> = {
    args?: Args;
    type: OutputType;
    __key: Key;
    __rootVal: RootVal;
    __context: Context;
    resolve?: OutputFieldResolver<Args, OutputType, RootVal, Context>;
    deprecationReason?: string;
    description?: string;
    extensions?: Readonly<GraphQLFieldExtensions<RootVal, unknown>>;
};
export declare const field: FieldFunc<unknown>;
declare type FieldFuncResolve<RootVal, Args extends {
    [Key in keyof Args]: Arg<any, any>;
}, OutputType extends OutputTypes, Key extends string, Context> = [
    RootVal
] extends [
    {
        [K in Key]: InferValueFromOutputType<OutputType>;
    }
] ? {
    resolve?: OutputFieldResolver<SomeTypeThatIsntARecordOfArgs extends Args ? {} : Args, OutputType, RootVal, Context>;
} : {
    resolve: OutputFieldResolver<SomeTypeThatIsntARecordOfArgs extends Args ? {} : Args, OutputType, RootVal, Context>;
};
declare type FieldFuncArgs<RootVal, Args extends {
    [Key in keyof Args]: Arg<any, any>;
}, OutputType extends OutputTypes, Key extends string, Context> = {
    args?: Args;
    type: OutputType;
    deprecationReason?: string;
    description?: string;
    extensions?: Readonly<GraphQLFieldExtensions<RootVal, unknown>>;
} & FieldFuncResolve<RootVal, Args, OutputType, Key, Context>;
declare type FieldFunc<OuterContext> = <RootVal, Args extends {
    [Key in keyof Args]: Arg<any, any>;
}, OutputType extends OutputTypes, Key extends string, Context extends OuterContext>(field: FieldFuncArgs<RootVal, Args, OutputType, Key, Context>) => OutputField<RootVal, Args, OutputType, Key, Context>;
export declare const object: ObjectTypeFunc<unknown>;
declare type ObjectTypeFunc<Context> = <RootVal>(youOnlyNeedToPassATypeParameterToThisFunctionYouPassTheActualRuntimeArgsOnTheResultOfThisFunction?: {
    youOnlyNeedToPassATypeParameterToThisFunctionYouPassTheActualRuntimeArgsOnTheResultOfThisFunction: true;
}) => <Name extends string, Fields extends {
    [Key in keyof Fields]: OutputField<RootVal, any, any, Extract<Key, string>, Context>;
}>(config: {
    name: Name;
    description?: string;
    deprecationReason?: string;
    fields: Fields | (() => Fields);
}) => ObjectType<RootVal, Name, Context>;
export declare type UnionType<TObjectType extends ObjectType<any, string, any>> = {
    kind: "union";
    __rootVal: TObjectType["__rootVal"];
    __context: TObjectType["__context"];
    graphQLType: GraphQLUnionType;
};
export declare const union: UnionTypeFunc<unknown>;
declare type UnionTypeFunc<Context> = <TObjectType extends ObjectType<any, string, Context>>(config: {
    name: string;
    description?: string;
    types: TObjectType[];
    resolveType: (type: TObjectType["__rootVal"], context: TObjectType["__context"], info: GraphQLResolveInfo, abstractType: GraphQLUnionType) => TObjectType["name"];
}) => UnionType<TObjectType>;
import * as typesThatDoNotUseContext from "./types-that-do-not-use-context";
export declare function bindTypesToContext<Context>(): {
    object: ObjectTypeFunc<Context>;
    union: UnionTypeFunc<Context>;
    field: FieldFunc<Context>;
    enumValues<Values extends readonly string[]>(values: [...Values]): Record<Values[number], typesThatDoNotUseContext.EnumValue<Values[number]>>;
    enum: typeof typesThatDoNotUseContext.enum;
    arg<Type extends InputType, DefaultValue extends typesThatDoNotUseContext.InferValueFromInputType<Type> | undefined>(arg: Arg<Type, DefaultValue>): Arg<Type, DefaultValue>;
    inputObject<Fields extends {
        [x: string]: {
            type: InputType;
            description?: string | undefined;
            defaultValue?: any;
        };
    }>(config: {
        name: string;
        description?: string | undefined;
        fields: Fields | (() => Fields);
    }): typesThatDoNotUseContext.InputObjectType<Fields>;
    scalar<Type_1>(scalar: import("graphql/type/definition").GraphQLScalarType): ScalarType<Type_1>;
    ID: ScalarType<string>;
    String: ScalarType<string>;
    Float: ScalarType<number>;
    Int: ScalarType<number>;
    Boolean: ScalarType<boolean>;
    list<Of extends typesThatDoNotUseContext.Types>(of: Of): typesThatDoNotUseContext.ListType<Of>;
    nonNull<Of_1 extends typesThatDoNotUseContext.TypesExcludingNonNull>(of: Of_1): typesThatDoNotUseContext.NonNullType<Of_1>;
};
export {};
