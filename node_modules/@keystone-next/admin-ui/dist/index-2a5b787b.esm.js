import * as Path from 'path';
import Path__default from 'path';
import hashString from '@emotion/hash';
import { executeSync, parse, GraphQLUnionType, GraphQLNonNull, GraphQLScalarType } from 'graphql';
import { s as staticAdminMetaQuery } from './admin-meta-graphql-87ba5444.esm.js';

function serializePathForImport(path) {
  // JSON.stringify is important here because it will escape windows style paths(and any thing else that might potentionally be in there)
  return JSON.stringify(path // Next is unhappy about imports that include .ts/tsx in them because TypeScript is unhappy with them becasue when doing a TypeScript compilation with tsc, the imports won't be written so they would be wrong there
  .replace(/\.tsx?$/, ''));
}

const appTemplate = (config, graphQLSchema, {
  configFileExists,
  projectAdminPath
}) => {
  const result = executeSync({
    document: staticAdminMetaQuery,
    schema: graphQLSchema,
    contextValue: {
      isAdminUIBuildProcess: true
    }
  });

  if (result.errors) {
    throw result.errors[0];
  }

  const {
    adminMeta
  } = result.data.keystone;
  const adminMetaQueryResultHash = hashString(JSON.stringify(adminMeta));

  const _allViews = new Set();

  Object.values(config.lists).forEach(list => {
    for (const fieldKey of Object.keys(list.fields)) {
      var _field$config$ui;

      const field = list.fields[fieldKey];

      _allViews.add(field.views);

      if ((_field$config$ui = field.config.ui) !== null && _field$config$ui !== void 0 && _field$config$ui.views) {
        _allViews.add(field.config.ui.views);
      }
    }
  });
  const allViews = [..._allViews].map(views => {
    const viewPath = Path__default.isAbsolute(views) ? Path__default.relative(Path__default.join(projectAdminPath, 'pages'), views) : views;
    return serializePathForImport(viewPath);
  }); // -- TEMPLATE START

  return `import { getApp } from '@keystone-next/admin-ui/pages/App';

${allViews.map((views, i) => `import * as view${i} from ${views};`).join('\n')}

${configFileExists ? `import * as adminConfig from "../../../admin/config";` : 'var adminConfig = {};'}

export default getApp({
  lazyMetadataQuery: ${JSON.stringify(getLazyMetadataQuery(graphQLSchema, adminMeta))},
  fieldViews: [${allViews.map((_, i) => `view${i}`)}],
  adminMetaHash: "${adminMetaQueryResultHash}",
  adminConfig: adminConfig
});
`; // -- TEMPLATE END
};

function getLazyMetadataQuery(graphqlSchema, adminMeta) {
  const selections = parse(`fragment x on y {
    keystone {
      adminMeta {
        lists {
          key
          isHidden
          fields {
            path
            createView {
              fieldMode
            }
          }
        }
      }
    }
  }`).definitions[0].selectionSet.selections;
  const queryType = graphqlSchema.getQueryType();

  if (queryType) {
    const getListByKey = name => adminMeta.lists.find(({
      key
    }) => key === name);

    const fields = queryType.getFields();

    if (fields['authenticatedItem'] !== undefined) {
      const authenticatedItemType = fields['authenticatedItem'].type;

      if (!(authenticatedItemType instanceof GraphQLUnionType) || authenticatedItemType.name !== 'AuthenticatedItem') {
        throw new Error(`The type of Query.authenticatedItem must be a type named AuthenticatedItem and be a union of types that refer to Keystone lists but it is "${authenticatedItemType.toString()}"`);
      }

      for (const type of authenticatedItemType.getTypes()) {
        const fields = type.getFields();
        const list = getListByKey(type.name);

        if (list === undefined) {
          throw new Error(`All members of the AuthenticatedItem union must refer to Keystone lists but "${type.name}" is in the AuthenticatedItem union but is not a Keystone list`);
        }

        let labelGraphQLField = fields[list.labelField];

        if (labelGraphQLField === undefined) {
          throw new Error(`The labelField for the list "${list.key}" is "${list.labelField}" but the GraphQL type does not have a field named "${list.labelField}"`);
        }

        let labelGraphQLFieldType = labelGraphQLField.type;

        if (labelGraphQLFieldType instanceof GraphQLNonNull) {
          labelGraphQLFieldType = labelGraphQLFieldType.ofType;
        }

        if (!(labelGraphQLFieldType instanceof GraphQLScalarType)) {
          throw new Error(`Label fields must be scalar GraphQL types but the labelField "${list.labelField}" on the list "${list.key}" is not a scalar type`);
        }

        const requiredArgs = labelGraphQLField.args.filter(arg => arg.defaultValue === undefined && arg.type instanceof GraphQLNonNull);

        if (requiredArgs.length) {
          throw new Error(`Label fields must have no required arguments but the labelField "${list.labelField}" on the list "${list.key}" has a required argument "${requiredArgs[0].name}"`);
        }
      }

      selections.push({
        kind: 'Field',
        name: {
          kind: 'Name',
          value: 'authenticatedItem'
        },
        selectionSet: {
          kind: 'SelectionSet',
          selections: authenticatedItemType.getTypes().map(({
            name
          }) => ({
            kind: 'InlineFragment',
            typeCondition: {
              kind: 'NamedType',
              name: {
                kind: 'Name',
                value: name
              }
            },
            selectionSet: {
              kind: 'SelectionSet',
              selections: [{
                kind: 'Field',
                name: {
                  kind: 'Name',
                  value: 'id'
                }
              }, {
                kind: 'Field',
                name: {
                  kind: 'Name',
                  value: getListByKey(name).labelField
                }
              }]
            }
          }))
        }
      });
    }
  } // We're returning the complete query AST here for explicit-ness


  return {
    kind: 'Document',
    definitions: [{
      kind: 'OperationDefinition',
      operation: 'query',
      selectionSet: {
        kind: 'SelectionSet',
        selections
      }
    }]
  };
}

const homeTemplate = `export { HomePage as default } from '@keystone-next/admin-ui/pages/HomePage';
`;

const listTemplate = listKey => `import { getListPage } from '@keystone-next/admin-ui/pages/ListPage';

export default getListPage(${JSON.stringify({
  listKey
})});
`;

const itemTemplate = listKey => `import { getItemPage } from '@keystone-next/admin-ui/pages/ItemPage';

export default getItemPage(${JSON.stringify({
  listKey
})})
`;

// so you might be thinking "that ../../../../../prisma/generated-client path looks very wrong, it's a directory above the user's keystone config?"
// and the answer to that is "yes, it's wrong from one perspective but it's also right because webpack things"
// in our next config (in this package at src/next-config.ts), we mark anything matching `prisma/generated-client` external
// this means that webpack will naively leave it as a require to ../../../../../prisma/generated-client
// ../../../../../prisma/generated-client is the exact right path to get to the generated client
// from where the bundled version of this file will be generated at so the require will end up working
const apiTemplate = `
import keystoneConfig from '../../../../keystone';
import { initConfig, createSystem, createApolloServerMicro } from '@keystone-next/keystone';
import { PrismaClient } from '../../../../../prisma/generated-client';

const initializedKeystoneConfig = initConfig(keystoneConfig);
const { graphQLSchema, keystone, createContext } = createSystem(initializedKeystoneConfig, '.keystone', 'none', PrismaClient);
const apolloServer = createApolloServerMicro({
  graphQLSchema,
  createContext,
  sessionStrategy: initializedKeystoneConfig.session ? initializedKeystoneConfig.session() : undefined,
  apolloConfig: initializedKeystoneConfig.graphql?.apolloConfig,
  connectionPromise: keystone.connect(),
});

export const config = {
  api: {
    bodyParser: false,
  },
};
export default apolloServer.createHandler({ path: '/api/graphql' });
`;

const noAccessTemplate = session => `import { getNoAccessPage } from '@keystone-next/admin-ui/pages/NoAccessPage';

export default getNoAccessPage(${JSON.stringify({
  sessionsEnabled: !!session
})})
`;

const pkgDir = Path.dirname(require.resolve('@keystone-next/admin-ui/package.json'));
const writeAdminFiles = (config, graphQLSchema, keystone, configFileExists, projectAdminPath) => {
  var _config$experimental;

  return [...['next.config.js', 'tsconfig.json'].map(outputPath => ({
    mode: 'copy',
    inputPath: Path.join(pkgDir, 'static', outputPath),
    outputPath
  })), {
    mode: 'write',
    outputPath: 'pages/no-access.js',
    src: noAccessTemplate(config.session)
  }, {
    mode: 'write',
    outputPath: 'pages/_app.js',
    src: appTemplate(config, graphQLSchema, {
      configFileExists,
      projectAdminPath
    })
  }, {
    mode: 'write',
    src: homeTemplate,
    outputPath: 'pages/index.js'
  }, ...Object.values(keystone.lists).map(({
    adminUILabels: {
      path
    },
    key
  }) => ({
    mode: 'write',
    src: listTemplate(key),
    outputPath: `pages/${path}/index.js`
  })), ...Object.values(keystone.lists).map(({
    adminUILabels: {
      path
    },
    key
  }) => ({
    mode: 'write',
    src: itemTemplate(key),
    outputPath: `pages/${path}/[id].js`
  })), ...((_config$experimental = config.experimental) !== null && _config$experimental !== void 0 && _config$experimental.enableNextJsGraphqlApiEndpoint ? [{
    mode: 'write',
    src: apiTemplate,
    outputPath: 'pages/api/graphql.js'
  }] : [])];
};

export { serializePathForImport as s, writeAdminFiles as w };
