'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var Path = require('path');
var fs = require('fs-extra');
var fastGlob = require('fast-glob');
var prettier = require('prettier');
var resolve = require('resolve');
var templates_dist_adminUi = require('../../dist/index-dffc8624.cjs.dev.js');
var url = require('url');
var session = require('@keystone-next/keystone/session');
var _objectSpread = require('@babel/runtime/helpers/objectSpread2');
var schema = require('@ts-gql/schema');
var graphql = require('graphql');
require('@emotion/hash');
require('../../dist/admin-meta-graphql-e60905b7.cjs.dev.js');
require('@apollo/client');

function _interopDefault (e) { return e && e.__esModule ? e : { 'default': e }; }

var Path__default = /*#__PURE__*/_interopDefault(Path);
var fs__default = /*#__PURE__*/_interopDefault(fs);
var fastGlob__default = /*#__PURE__*/_interopDefault(fastGlob);
var prettier__default = /*#__PURE__*/_interopDefault(prettier);
var resolve__default = /*#__PURE__*/_interopDefault(resolve);
var url__default = /*#__PURE__*/_interopDefault(url);

const formatSource = (src, parser = 'babel') => prettier__default['default'].format(src, {
  parser,
  trailingComma: 'es5',
  singleQuote: true
});

function getDoesAdminConfigExist() {
  try {
    const configPath = Path__default['default'].join(process.cwd(), 'admin', 'config');
    resolve__default['default'].sync(configPath, {
      extensions: ['.ts', '.tsx', '.js'],
      preserveSymlinks: false
    });
    return true;
  } catch (err) {
    if (err.code === 'MODULE_NOT_FOUND') {
      return false;
    }

    throw err;
  }
}

async function writeAdminFile(file, projectAdminPath) {
  const outputFilename = Path__default['default'].join(projectAdminPath, file.outputPath);

  if (file.mode === 'copy') {
    if (!Path__default['default'].isAbsolute(file.inputPath)) {
      throw new Error(`An inputPath of "${file.inputPath}" was provided to copy but inputPaths must be absolute`);
    }

    await fs__default['default'].ensureDir(Path__default['default'].dirname(outputFilename)); // TODO: should we use copyFile or copy?

    await fs__default['default'].copyFile(file.inputPath, outputFilename);
  }

  if (file.mode === 'write') {
    await fs__default['default'].outputFile(outputFilename, formatSource(file.src));
  }

  return Path__default['default'].normalize(outputFilename);
}

const generateAdminUI = async (config, graphQLSchema, keystone, projectAdminPath) => {
  var _config$ui$getAdditio, _config$ui, _config$ui$getAdditio2;

  // Nuke any existing files in our target directory
  await fs__default['default'].remove(projectAdminPath); // Write out the files configured by the user

  const userPages = (_config$ui$getAdditio = (_config$ui = config.ui) === null || _config$ui === void 0 ? void 0 : (_config$ui$getAdditio2 = _config$ui.getAdditionalFiles) === null || _config$ui$getAdditio2 === void 0 ? void 0 : _config$ui$getAdditio2.map(x => x(config))) !== null && _config$ui$getAdditio !== void 0 ? _config$ui$getAdditio : [];
  const userFilesToWrite = (await Promise.all(userPages)).flat();
  const savedFiles = await Promise.all(userFilesToWrite.map(file => writeAdminFile(file, projectAdminPath)));
  const uniqueFiles = new Set(savedFiles); // Write out the built-in admin UI files. Don't overwrite any user-defined pages.

  const configFileExists = getDoesAdminConfigExist();
  const adminFiles = templates_dist_adminUi.writeAdminFiles(config, graphQLSchema, keystone, configFileExists, projectAdminPath);
  await Promise.all(adminFiles.filter(x => !uniqueFiles.has(Path__default['default'].normalize(x.outputPath))).map(file => writeAdminFile(file, projectAdminPath))); // Add files to pages/ which point to any files which exist in admin/pages

  const userPagesDir = Path__default['default'].join(process.cwd(), 'admin', 'pages');
  const files = await fastGlob__default['default']('**/*.{js,jsx,ts,tsx}', {
    cwd: userPagesDir
  });
  await Promise.all(files.map(async filename => {
    const outputFilename = Path__default['default'].join(projectAdminPath, 'pages', filename);
    const path = Path__default['default'].relative(Path__default['default'].dirname(outputFilename), Path__default['default'].join(userPagesDir, filename));
    const importPath = templates_dist_adminUi.serializePathForImport(path);
    await fs__default['default'].outputFile(outputFilename, `export { default } from ${importPath}`);
  }));
};

const createAdminUIServer = async (ui, createContext, dev, projectAdminPath, sessionStrategy) => {
  var _ui$publicPages;

  /** We do this to stop webpack from bundling next inside of next */
  const thing = 'next';

  const next = require(thing);

  const app = next({
    dev,
    dir: projectAdminPath
  });
  const handle = app.getRequestHandler();
  await app.prepare();
  const publicPages = (_ui$publicPages = ui === null || ui === void 0 ? void 0 : ui.publicPages) !== null && _ui$publicPages !== void 0 ? _ui$publicPages : [];
  return async (req, res) => {
    var _ui$pageMiddleware;

    const {
      pathname
    } = url__default['default'].parse(req.url);

    if (pathname !== null && pathname !== void 0 && pathname.startsWith('/_next') || pathname === '/api/graphql') {
      handle(req, res);
      return;
    }

    const context = createContext({
      sessionContext: sessionStrategy ? await session.createSessionContext(sessionStrategy, req, res, createContext) : undefined
    });
    const isValidSession = ui !== null && ui !== void 0 && ui.isAccessAllowed ? await ui.isAccessAllowed(context) : sessionStrategy ? context.session !== undefined : true;
    const maybeRedirect = await (ui === null || ui === void 0 ? void 0 : (_ui$pageMiddleware = ui.pageMiddleware) === null || _ui$pageMiddleware === void 0 ? void 0 : _ui$pageMiddleware.call(ui, {
      req,
      session: context.session,
      isValidSession,
      createContext
    }));

    if (maybeRedirect) {
      res.redirect(maybeRedirect.to);
      return;
    }

    if (!isValidSession && !publicPages.includes(url__default['default'].parse(req.url).pathname)) {
      app.render(req, res, '/no-access');
    } else {
      handle(req, res);
    }
  };
};

function createAdminMeta(config, keystone) {
  const {
    ui,
    lists,
    session
  } = config;
  const adminMetaRoot = {
    enableSessionItem: (ui === null || ui === void 0 ? void 0 : ui.enableSessionItem) || false,
    enableSignout: session !== undefined,
    listsByKey: {},
    lists: []
  };
  Object.keys(lists).forEach(key => {
    var _ref, _listConfig$ui, _ref2, _listConfig$ui$descri, _listConfig$ui2, _listConfig$ui$listVi, _listConfig$ui3, _listConfig$ui3$listV, _ref3, _listConfig$ui4, _listConfig$ui4$listV, _ref4, _listConfig$ui5, _listConfig$ui5$listV;

    const listConfig = lists[key];
    const list = keystone.lists[key]; // Default the labelField to `name`, `label`, or `title` if they exist; otherwise fall back to `id`

    const labelField = (_ref = (_listConfig$ui = listConfig.ui) === null || _listConfig$ui === void 0 ? void 0 : _listConfig$ui.labelField) !== null && _ref !== void 0 ? _ref : listConfig.fields.label ? 'label' : listConfig.fields.name ? 'name' : listConfig.fields.title ? 'title' : 'id';
    adminMetaRoot.listsByKey[key] = {
      key,
      labelField,
      description: (_ref2 = (_listConfig$ui$descri = (_listConfig$ui2 = listConfig.ui) === null || _listConfig$ui2 === void 0 ? void 0 : _listConfig$ui2.description) !== null && _listConfig$ui$descri !== void 0 ? _listConfig$ui$descri : listConfig.description) !== null && _ref2 !== void 0 ? _ref2 : null,
      label: list.adminUILabels.label,
      singular: list.adminUILabels.singular,
      plural: list.adminUILabels.plural,
      path: list.adminUILabels.path,
      fields: [],
      pageSize: (_listConfig$ui$listVi = (_listConfig$ui3 = listConfig.ui) === null || _listConfig$ui3 === void 0 ? void 0 : (_listConfig$ui3$listV = _listConfig$ui3.listView) === null || _listConfig$ui3$listV === void 0 ? void 0 : _listConfig$ui3$listV.pageSize) !== null && _listConfig$ui$listVi !== void 0 ? _listConfig$ui$listVi : 50,
      initialColumns: (_ref3 = (_listConfig$ui4 = listConfig.ui) === null || _listConfig$ui4 === void 0 ? void 0 : (_listConfig$ui4$listV = _listConfig$ui4.listView) === null || _listConfig$ui4$listV === void 0 ? void 0 : _listConfig$ui4$listV.initialColumns) !== null && _ref3 !== void 0 ? _ref3 : [labelField],
      initialSort: (_ref4 = (_listConfig$ui5 = listConfig.ui) === null || _listConfig$ui5 === void 0 ? void 0 : (_listConfig$ui5$listV = _listConfig$ui5.listView) === null || _listConfig$ui5$listV === void 0 ? void 0 : _listConfig$ui5$listV.initialSort) !== null && _ref4 !== void 0 ? _ref4 : null,
      itemQueryName: list.gqlNames.itemQueryName,
      listQueryName: list.gqlNames.listQueryName.replace('all', '')
    };
    adminMetaRoot.lists.push(adminMetaRoot.listsByKey[key]);
  });
  let uniqueViewCount = -1;
  const stringViewsToIndex = {};

  function getViewId(view) {
    if (stringViewsToIndex[view] !== undefined) {
      return stringViewsToIndex[view];
    }

    uniqueViewCount++;
    stringViewsToIndex[view] = uniqueViewCount;
    return uniqueViewCount;
  } // Populate .fields array


  Object.keys(lists).forEach(key => {
    const listConfig = lists[key];
    const list = keystone.lists[key];

    for (const fieldKey of Object.keys(listConfig.fields).filter(path => {
      var _listConfig$fields$pa;

      return ((_listConfig$fields$pa = listConfig.fields[path].config.access) === null || _listConfig$fields$pa === void 0 ? void 0 : _listConfig$fields$pa.read) !== false;
    })) {
      var _field$config$ui, _field$getAdminMeta, _field$getAdminMeta2;

      const field = listConfig.fields[fieldKey];
      adminMetaRoot.listsByKey[key].fields.push({
        label: list.fieldsByPath[fieldKey].label,
        viewsIndex: getViewId(field.views),
        customViewsIndex: ((_field$config$ui = field.config.ui) === null || _field$config$ui === void 0 ? void 0 : _field$config$ui.views) === undefined ? null : getViewId(field.config.ui.views),
        fieldMeta: (_field$getAdminMeta = (_field$getAdminMeta2 = field.getAdminMeta) === null || _field$getAdminMeta2 === void 0 ? void 0 : _field$getAdminMeta2.call(field, key, fieldKey, adminMetaRoot)) !== null && _field$getAdminMeta !== void 0 ? _field$getAdminMeta : null,
        isOrderable: list.fieldsByPath[fieldKey].isOrderable || fieldKey === 'id',
        path: fieldKey,
        listKey: key
      });
    }
  });
  return adminMetaRoot;
}

const types = schema.bindTypesToContext();
function getAdminMetaSchema({
  keystone,
  config,
  schema
}) {
  var _config$ui$isAccessAl, _config$ui;

  const adminMetaRoot = createAdminMeta(config, keystone);
  const isAccessAllowed = config.session === undefined ? undefined : (_config$ui$isAccessAl = (_config$ui = config.ui) === null || _config$ui === void 0 ? void 0 : _config$ui.isAccessAllowed) !== null && _config$ui$isAccessAl !== void 0 ? _config$ui$isAccessAl : ({
    session
  }) => session !== undefined;
  const jsonScalar = types.scalar(schema.getType('JSON'));
  const KeystoneAdminUIFieldMeta = types.object()({
    name: 'KeystoneAdminUIFieldMeta',
    fields: {
      path: types.field({
        type: types.nonNull(types.String)
      }),
      label: types.field({
        type: types.nonNull(types.String)
      }),
      isOrderable: types.field({
        type: types.nonNull(types.Boolean)
      }),
      fieldMeta: types.field({
        type: jsonScalar
      }),
      viewsIndex: types.field({
        type: types.nonNull(types.Int)
      }),
      customViewsIndex: types.field({
        type: types.Int
      }),
      createView: types.field({
        resolve(rootVal) {
          return {
            fieldPath: rootVal.path,
            listKey: rootVal.listKey
          };
        },

        type: types.nonNull(types.object()({
          name: 'KeystoneAdminUIFieldMetaCreateView',
          fields: {
            fieldMode: types.field({
              type: types.nonNull(types.enum({
                name: 'KeystoneAdminUIFieldMetaCreateViewFieldMode',
                values: types.enumValues(['edit', 'hidden'])
              })),

              async resolve(rootVal, args, context) {
                var _listConfig$fields$ro, _listConfig$fields$ro2, _listConfig$fields$ro3, _listConfig$ui, _listConfig$ui$create;

                if ('isAdminUIBuildProcess' in context) {
                  throw new Error('KeystoneAdminUIFieldMetaCreateView.fieldMode cannot be resolved during the build process');
                }

                const listConfig = config.lists[rootVal.listKey];
                const sessionFunction = (_listConfig$fields$ro = (_listConfig$fields$ro2 = listConfig.fields[rootVal.fieldPath].config.ui) === null || _listConfig$fields$ro2 === void 0 ? void 0 : (_listConfig$fields$ro3 = _listConfig$fields$ro2.createView) === null || _listConfig$fields$ro3 === void 0 ? void 0 : _listConfig$fields$ro3.fieldMode) !== null && _listConfig$fields$ro !== void 0 ? _listConfig$fields$ro : (_listConfig$ui = listConfig.ui) === null || _listConfig$ui === void 0 ? void 0 : (_listConfig$ui$create = _listConfig$ui.createView) === null || _listConfig$ui$create === void 0 ? void 0 : _listConfig$ui$create.defaultFieldMode;
                return runMaybeFunction(sessionFunction, 'edit', {
                  session: context.session
                });
              }

            })
          }
        }))
      }),
      listView: types.field({
        resolve(rootVal) {
          return {
            fieldPath: rootVal.path,
            listKey: rootVal.listKey
          };
        },

        type: types.nonNull(types.object()({
          name: 'KeystoneAdminUIFieldMetaListView',
          fields: {
            fieldMode: types.field({
              type: types.nonNull(types.enum({
                name: 'KeystoneAdminUIFieldMetaListViewFieldMode',
                values: types.enumValues(['read', 'hidden'])
              })),

              async resolve(rootVal, args, context) {
                var _listConfig$fields$ro4, _listConfig$fields$ro5, _listConfig$fields$ro6, _listConfig$ui2, _listConfig$ui2$listV;

                if ('isAdminUIBuildProcess' in context) {
                  throw new Error('KeystoneAdminUIFieldMetaListView.fieldMode cannot be resolved during the build process');
                }

                const listConfig = config.lists[rootVal.listKey];
                const sessionFunction = (_listConfig$fields$ro4 = (_listConfig$fields$ro5 = listConfig.fields[rootVal.fieldPath].config.ui) === null || _listConfig$fields$ro5 === void 0 ? void 0 : (_listConfig$fields$ro6 = _listConfig$fields$ro5.listView) === null || _listConfig$fields$ro6 === void 0 ? void 0 : _listConfig$fields$ro6.fieldMode) !== null && _listConfig$fields$ro4 !== void 0 ? _listConfig$fields$ro4 : (_listConfig$ui2 = listConfig.ui) === null || _listConfig$ui2 === void 0 ? void 0 : (_listConfig$ui2$listV = _listConfig$ui2.listView) === null || _listConfig$ui2$listV === void 0 ? void 0 : _listConfig$ui2$listV.defaultFieldMode;
                return runMaybeFunction(sessionFunction, 'read', {
                  session: context.session
                });
              }

            })
          }
        }))
      }),
      itemView: types.field({
        args: {
          id: types.arg({
            type: types.nonNull(types.ID)
          })
        },

        resolve(rootVal, args) {
          return {
            fieldPath: rootVal.path,
            listKey: rootVal.listKey,
            itemId: args.id
          };
        },

        type: types.object()({
          name: 'KeystoneAdminUIFieldMetaItemView',
          fields: {
            fieldMode: types.field({
              type: types.nonNull(types.enum({
                name: 'KeystoneAdminUIFieldMetaItemViewFieldMode',
                values: types.enumValues(['edit', 'read', 'hidden'])
              })),

              async resolve(rootVal, args, context) {
                var _listConfig$fields$ro7, _listConfig$fields$ro8, _listConfig$fields$ro9, _listConfig$ui3, _listConfig$ui3$itemV;

                if ('isAdminUIBuildProcess' in context) {
                  throw new Error('KeystoneAdminUIFieldMetaItemView.fieldMode cannot be resolved during the build process');
                }

                const item = await context.sudo().lists[rootVal.listKey].findOne({
                  where: {
                    id: rootVal.itemId
                  },
                  resolveFields: false
                });
                const listConfig = config.lists[rootVal.listKey];
                const sessionFunction = (_listConfig$fields$ro7 = (_listConfig$fields$ro8 = listConfig.fields[rootVal.fieldPath].config.ui) === null || _listConfig$fields$ro8 === void 0 ? void 0 : (_listConfig$fields$ro9 = _listConfig$fields$ro8.itemView) === null || _listConfig$fields$ro9 === void 0 ? void 0 : _listConfig$fields$ro9.fieldMode) !== null && _listConfig$fields$ro7 !== void 0 ? _listConfig$fields$ro7 : (_listConfig$ui3 = listConfig.ui) === null || _listConfig$ui3 === void 0 ? void 0 : (_listConfig$ui3$itemV = _listConfig$ui3.itemView) === null || _listConfig$ui3$itemV === void 0 ? void 0 : _listConfig$ui3$itemV.defaultFieldMode;
                return runMaybeFunction(sessionFunction, 'edit', {
                  session: context.session,
                  item
                });
              }

            })
          }
        })
      })
    }
  });
  const KeystoneAdminUISort = types.object()({
    name: 'KeystoneAdminUISort',
    fields: {
      field: types.field({
        type: types.nonNull(types.String)
      }),
      direction: types.field({
        type: types.nonNull(types.enum({
          name: 'KeystoneAdminUISortDirection',
          values: types.enumValues(['ASC', 'DESC'])
        }))
      })
    }
  });
  const KeystoneAdminUIListMeta = types.object()({
    name: 'KeystoneAdminUIListMeta',
    fields: {
      key: types.field({
        type: types.nonNull(types.String)
      }),
      itemQueryName: types.field({
        type: types.nonNull(types.String)
      }),
      listQueryName: types.field({
        type: types.nonNull(types.String)
      }),
      hideCreate: types.field({
        type: types.nonNull(types.Boolean),

        resolve(rootVal, args, context) {
          var _listConfig$ui4;

          if ('isAdminUIBuildProcess' in context) {
            throw new Error('KeystoneAdminUIListMeta.hideCreate cannot be resolved during the build process');
          }

          const listConfig = config.lists[rootVal.key];
          return runMaybeFunction((_listConfig$ui4 = listConfig.ui) === null || _listConfig$ui4 === void 0 ? void 0 : _listConfig$ui4.hideCreate, false, {
            session: context.session
          });
        }

      }),
      hideDelete: types.field({
        type: types.nonNull(types.Boolean),

        resolve(rootVal, args, context) {
          var _listConfig$ui5;

          if ('isAdminUIBuildProcess' in context) {
            throw new Error('KeystoneAdminUIListMeta.hideDelete cannot be resolved during the build process');
          }

          const listConfig = config.lists[rootVal.key];
          return runMaybeFunction((_listConfig$ui5 = listConfig.ui) === null || _listConfig$ui5 === void 0 ? void 0 : _listConfig$ui5.hideDelete, false, {
            session: context.session
          });
        }

      }),
      path: types.field({
        type: types.nonNull(types.String)
      }),
      label: types.field({
        type: types.nonNull(types.String)
      }),
      singular: types.field({
        type: types.nonNull(types.String)
      }),
      plural: types.field({
        type: types.nonNull(types.String)
      }),
      description: types.field({
        type: types.String
      }),
      initialColumns: types.field({
        type: types.nonNull(types.list(types.nonNull(types.String)))
      }),
      pageSize: types.field({
        type: types.nonNull(types.Int)
      }),
      labelField: types.field({
        type: types.nonNull(types.String)
      }),
      fields: types.field({
        type: types.nonNull(types.list(types.nonNull(KeystoneAdminUIFieldMeta)))
      }),
      initialSort: types.field({
        type: KeystoneAdminUISort
      }),
      isHidden: types.field({
        type: types.nonNull(types.Boolean),

        resolve(rootVal, args, context) {
          var _listConfig$ui6;

          if ('isAdminUIBuildProcess' in context) {
            throw new Error('KeystoneAdminUIListMeta.isHidden cannot be resolved during the build process');
          }

          const listConfig = config.lists[rootVal.key];
          return runMaybeFunction((_listConfig$ui6 = listConfig.ui) === null || _listConfig$ui6 === void 0 ? void 0 : _listConfig$ui6.isHidden, false, {
            session: context.session
          });
        }

      })
    }
  });
  const adminMeta = types.object()({
    name: 'KeystoneAdminMeta',
    fields: {
      enableSignout: types.field({
        type: types.nonNull(types.Boolean)
      }),
      enableSessionItem: types.field({
        type: types.nonNull(types.Boolean)
      }),
      lists: types.field({
        type: types.nonNull(types.list(types.nonNull(KeystoneAdminUIListMeta)))
      }),
      list: types.field({
        type: KeystoneAdminUIListMeta,
        args: {
          key: types.arg({
            type: types.nonNull(types.String)
          })
        },

        resolve(rootVal, {
          key
        }) {
          return rootVal.listsByKey[key];
        }

      })
    }
  });
  const KeystoneMeta = types.nonNull(types.object()({
    name: 'KeystoneMeta',
    fields: {
      adminMeta: types.field({
        type: types.nonNull(adminMeta),

        resolve(rootVal, args, context) {
          if ('isAdminUIBuildProcess' in context || isAccessAllowed === undefined) {
            return adminMetaRoot;
          }

          return Promise.resolve(isAccessAllowed(context)).then(isAllowed => {
            if (isAllowed) {
              return adminMetaRoot;
            } // TODO: ughhhhhh, we really need to talk about errors.
            // mostly unrelated to above: error or return null here(+ make field nullable)?s


            throw new Error('Access denied');
          });
        }

      })
    }
  }));
  const schemaConfig = schema.toConfig();
  const queryTypeConfig = schema.getQueryType().toConfig();
  return new graphql.GraphQLSchema(_objectSpread(_objectSpread({}, schemaConfig), {}, {
    types: schemaConfig.types.filter(x => x.name !== 'Query'),
    query: new graphql.GraphQLObjectType(_objectSpread(_objectSpread({}, queryTypeConfig), {}, {
      fields: () => _objectSpread(_objectSpread({}, typeof queryTypeConfig.fields === 'function' ? queryTypeConfig.fields() : queryTypeConfig.fields), {}, {
        keystone: {
          type: KeystoneMeta.graphQLType,

          resolve() {
            return {};
          }

        }
      })
    }))
  }));
}

function runMaybeFunction(sessionFunction, defaultValue, args) {
  if (typeof sessionFunction === 'function') {
    return sessionFunction(args);
  }

  if (typeof sessionFunction === 'undefined') {
    return defaultValue;
  }

  return sessionFunction;
}

async function buildAdminUI(projectAdminPath) {
  // importing next/dist/build is quite expensive so we're requiring it lazily

  /** We do this to stop webpack from bundling next inside of next */
  const next = 'next/dist/build';

  const build = require(next).default;

  await build(projectAdminPath);
}

exports.buildAdminUI = buildAdminUI;
exports.createAdminUIServer = createAdminUIServer;
exports.generateAdminUI = generateAdminUI;
exports.getAdminMetaSchema = getAdminMetaSchema;
