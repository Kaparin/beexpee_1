import fs from 'fs';
import path from 'path';
import { uriToCredentials, createDatabase, getGenerator, formatSchema } from '@prisma/sdk';
import { BaseKeystoneAdapter, BaseListAdapter, BaseFieldAdapter } from '@keystone-next/keystone-legacy';
import { flatten, defaultObj, mapKeys, identity } from '@keystone-next/utils-legacy';
import { Migrate } from '@prisma/migrate';
import chalk from 'chalk';
import slugify from '@sindresorhus/slugify';
import prompts from 'prompts';

// prompts also returns an undefined value on SIGINT which we really just want to exit on

async function confirmPrompt(message) {
  const {
    value
  } = await prompts({
    name: 'value',
    type: 'confirm',
    message,
    initial: true
  });

  if (value === undefined) {
    process.exit(1);
  }

  return value;
}
async function textPrompt(message) {
  const {
    value
  } = await prompts({
    name: 'value',
    type: 'text',
    message
  });

  if (value === undefined) {
    process.exit(1);
  }

  return value;
}

// setting the env variable _just_ long enough for Migrate to
// read it and then we reset it immediately after.
// Migrate reads the env variables a single time when it starts the child process that it talks to
// note that we could only run this once per Migrate instance but we're going to do it consistently for all migrate calls
// so that calls can moved around freely without implictly relying on some other migrate command being called before it

function runMigrateWithDbUrl(dbUrl, cb) {
  let prevDBURLFromEnv = process.env.DATABASE_URL;

  try {
    process.env.DATABASE_URL = dbUrl;
    return cb();
  } finally {
    process.env.DATABASE_URL = prevDBURLFromEnv;
  }
}

async function withMigrate(dbUrl, schemaPath, cb) {
  await ensureDatabaseExists(dbUrl, path.dirname(schemaPath));
  const migrate = new Migrate(schemaPath);

  try {
    return await cb(migrate);
  } finally {
    migrate.stop();
  }
}

async function runPrototypeMigrations(dbUrl, schema, schemaPath) {
  let before = Date.now();
  let migration = await withMigrate(dbUrl, schemaPath, async (migrate) => runMigrateWithDbUrl(dbUrl, () => migrate.engine.schemaPush({
    // TODO: we probably want to do something like db push does where either there's
    // a prompt or an argument needs to be passed to make it force(i.e. lose data)
    force: true,
    schema
  })));

  if (migration.warnings.length === 0 && migration.executedSteps === 0) {
    console.info(`✨ The database is already in sync with the Prisma schema.`);
  } else {
    console.info(`✨ Your database is now in sync with your schema. Done in ${formatms(Date.now() - before)}`);
  }
} // https://github.com/prisma/prisma/blob/527b6bd35e7fe4dbe854653f872a07b25febeb65/src/packages/migrate/src/commands/MigrateDeploy.ts

async function deployMigrations(dbUrl, schemaPath) {
  return withMigrate(dbUrl, schemaPath, async migrate => {
    const diagnoseResult = await runMigrateWithDbUrl(dbUrl, () => migrate.diagnoseMigrationHistory({
      optInToShadowDatabase: false
    }));
    const listMigrationDirectoriesResult = await runMigrateWithDbUrl(dbUrl, () => migrate.listMigrationDirectories());
    console.info(); // empty line

    if (listMigrationDirectoriesResult.migrations.length > 0) {
      const migrations = listMigrationDirectoriesResult.migrations;
      console.info(`${migrations.length} migration${migrations.length > 1 ? 's' : ''} found in .keystone/prisma/migrations`);
    } else {
      console.info(`No migration found in .keystone/prisma/migrations`);
    }

    const editedMigrationNames = diagnoseResult.editedMigrationNames;

    if (editedMigrationNames.length > 0) {
      console.info(`${chalk.yellow('WARNING The following migrations have been modified since they were applied:')}
${editedMigrationNames.join('\n')}`);
    }

    const {
      appliedMigrationNames: migrationIds
    } = await runMigrateWithDbUrl(dbUrl, () => migrate.applyMigrations());
    console.info(); // empty line

    if (migrationIds.length === 0) {
      console.log(chalk.greenBright(`No pending migrations to apply.`));
    } else {
      console.log(`The following migration${migrationIds.length > 1 ? 's' : ''} have been applied:\n\n${printFilesFromMigrationIds(migrationIds)}

${chalk.greenBright('All migrations have been successfully applied.')}`);
    }
  });
} // https://github.com/prisma/prisma/blob/527b6bd35e7fe4dbe854653f872a07b25febeb65/src/packages/migrate/src/commands/MigrateReset.ts

async function resetDatabaseWithMigrations(dbUrl, schemaPath) {
  return withMigrate(dbUrl, schemaPath, async migrate => {
    await runMigrateWithDbUrl(dbUrl, () => migrate.reset());
    const {
      appliedMigrationNames: migrationIds
    } = await runMigrateWithDbUrl(dbUrl, () => migrate.applyMigrations());
    console.log(`${chalk.green('Database reset successful')}`);

    if (migrationIds.length) {
      console.info(`\nThe following migration(s) have been applied:\n\n${printFilesFromMigrationIds(migrationIds)}`);
    }
  });
}
// TODO: don't have process.exit calls here
async function createMigration(dbUrl, prismaSchema, schemaPath, cliOptions) {
  return withMigrate(dbUrl, schemaPath, async migrate => {
    // see if we need to reset the database
    // note that the other action devDiagnostic can return is createMigration
    // that doesn't necessarily mean that we need to create a migration
    // it only means that we don't need to reset the database
    const devDiagnostic = await runMigrateWithDbUrl(dbUrl, () => migrate.devDiagnostic()); // when the action is reset, the database is somehow inconsistent with the migrations so we need to reset it
    // (not just some migrations need to be applied but there's some inconsistency)

    if (devDiagnostic.action.tag === 'reset') {
      const credentials = uriToCredentials(dbUrl);

      if (cliOptions.acceptDataLoss === false) {
        console.log(`${devDiagnostic.action.reason}

        We need to reset the ${credentials.type} database "${credentials.database}" at ${getDbLocation(credentials)}.`);

        if (!process.stdout.isTTY) {
          console.log("We've detected that you're in a non-interactive environment so you need to pass --accept-data-loss to reset the database");
          process.exit(1);
        }

        const confirmedReset = await confirmPrompt(`Do you want to continue? ${chalk.red('All data will be lost')}.`);
        console.info(); // empty line

        if (!confirmedReset) {
          console.info('Reset cancelled.');
          process.exit(0);
        }
      } // Do the reset


      await migrate.reset();
    }

    let {
      appliedMigrationNames
    } = await runMigrateWithDbUrl(dbUrl, () => migrate.applyMigrations()); // Inform user about applied migrations now

    if (appliedMigrationNames.length) {
      console.info(`✨ The following migration(s) have been applied:\n\n${printFilesFromMigrationIds(appliedMigrationNames)}`);
    } // evaluateDataLoss basically means "try to create a migration but don't write it"
    // so we can tell the user whether it can be executed and if there will be data loss


    const evaluateDataLossResult = await runMigrateWithDbUrl(dbUrl, () => migrate.evaluateDataLoss()); // there are no steps to the migration so we need to make sure the user wants to create an empty migration

    if (!evaluateDataLossResult.migrationSteps.length && cliOptions.allowEmpty === false) {
      console.log('There have been no changes to your schema that require a migration');

      if (process.stdout.isTTY) {
        if (!(await confirmPrompt('Are you sure that you want to create an empty migration?'))) {
          process.exit(0);
        }
      } else {
        console.log("We've detected that you're in a non-interactive environment so you need to pass --allow-empty to create an empty migration"); // note this is a failure even though the migrations are up to date
        // since the user said "i want to create a migration" and we've said no

        process.exit(1);
      }
    }

    let migrationCanBeApplied = !evaluateDataLossResult.unexecutableSteps.length; // see the link below for what "unexecutable steps" are
    // https://github.com/prisma/prisma-engines/blob/c65d20050f139a7917ef2efc47a977338070ea61/migration-engine/connectors/sql-migration-connector/src/sql_destructive_change_checker/unexecutable_step_check.rs
    // the tl;dr is "making things non null when there are nulls in the db"

    if (!migrationCanBeApplied) {
      console.log(`${chalk.bold.red('\n⚠️ We found changes that cannot be executed:\n')}`);

      for (const item of evaluateDataLossResult.unexecutableSteps) {
        console.log(`  • Step ${item.stepIndex} ${item.message}`);
      }
    } // warnings mean "if the migration was applied to the database you're connected to, you will lose x data"
    // note that if you have a field where all of the values are null on your local db and you've removed it, you won't get a warning here.
    // there will be a warning in a comment in the generated migration though.


    if (evaluateDataLossResult.warnings.length) {
      console.log(chalk.bold(`\n⚠️  Warnings:\n`));

      for (const warning of evaluateDataLossResult.warnings) {
        console.log(`  • ${warning.message}`);
      }
    }

    console.log(); // for an empty line

    let migrationName = await (() => {
      if (cliOptions.name) {
        return cliOptions.name;
      }

      if (process.stdout.isTTY) {
        return getMigrationName();
      }

      console.log("We've detected that you're in a non-interactive environment so you need to pass --name to provide a migration name");
      process.exit(1);
    })(); // note this only creates the migration, it does not apply it

    let {
      generatedMigrationName
    } = await runMigrateWithDbUrl(dbUrl, () => migrate.createMigration({
      migrationsDirectoryPath: migrate.migrationsDirectoryPath,
      // https://github.com/prisma/prisma-engines/blob/11dfcc85d7f9b55235e31630cd87da7da3aed8cc/migration-engine/core/src/commands/create_migration.rs#L16-L17
      // draft means "create an empty migration even if there are no changes rather than exiting"
      draft: true,
      prismaSchema,
      migrationName
    }));
    console.log(`✨ A migration has been created at .keystone/prisma/migrations/${generatedMigrationName}`);
  });
} // TODO: don't have process.exit calls here

async function devMigrations(dbUrl, prismaSchema, schemaPath) {
  return withMigrate(dbUrl, schemaPath, async migrate => {
    // see if we need to reset the database
    // note that the other action devDiagnostic can return is createMigration
    // that doesn't necessarily mean that we need to create a migration
    // it only means that we don't need to reset the database
    const devDiagnostic = await runMigrateWithDbUrl(dbUrl, () => migrate.devDiagnostic()); // when the action is reset, the database is somehow inconsistent with the migrations so we need to reset it
    // (not just some migrations need to be applied but there's some inconsistency)

    if (devDiagnostic.action.tag === 'reset') {
      const credentials = uriToCredentials(dbUrl);
      console.log(`${devDiagnostic.action.reason}

We need to reset the ${credentials.type} database "${credentials.database}" at ${getDbLocation(credentials)}.`);
      const confirmedReset = await confirmPrompt(`Do you want to continue? ${chalk.red('All data will be lost')}.`);
      console.info(); // empty line

      if (!confirmedReset) {
        console.info('Reset cancelled.');
        process.exit(0);
      } // Do the reset


      await migrate.reset();
    }

    let {
      appliedMigrationNames
    } = await runMigrateWithDbUrl(dbUrl, () => migrate.applyMigrations()); // Inform user about applied migrations now

    if (appliedMigrationNames.length) {
      console.info(`✨ The following migration(s) have been applied:\n\n${printFilesFromMigrationIds(appliedMigrationNames)}`);
    } // evaluateDataLoss basically means "try to create a migration but don't write it"
    // so we can tell the user whether it can be executed and if there will be data loss


    const evaluateDataLossResult = await runMigrateWithDbUrl(dbUrl, () => migrate.evaluateDataLoss()); // if there are no steps, there was no change to the prisma schema so we don't need to create a migration

    if (evaluateDataLossResult.migrationSteps.length) {
      console.log('✨ There has been a change to your Keystone schema that requires a migration');
      let migrationCanBeApplied = !evaluateDataLossResult.unexecutableSteps.length; // see the link below for what "unexecutable steps" are
      // https://github.com/prisma/prisma-engines/blob/c65d20050f139a7917ef2efc47a977338070ea61/migration-engine/connectors/sql-migration-connector/src/sql_destructive_change_checker/unexecutable_step_check.rs
      // the tl;dr is "making things non null when there are nulls in the db"

      if (!migrationCanBeApplied) {
        console.log(`${chalk.bold.red('\n⚠️ We found changes that cannot be executed:\n')}`);

        for (const item of evaluateDataLossResult.unexecutableSteps) {
          console.log(`  • Step ${item.stepIndex} ${item.message}`);
        }
      } // warnings mean "if the migration was applied to the database you're connected to, you will lose x data"
      // note that if you have a field where all of the values are null on your local db and you've removed it, you won't get a warning here.
      // there will be a warning in a comment in the generated migration though.


      if (evaluateDataLossResult.warnings.length) {
        console.log(chalk.bold(`\n⚠️  Warnings:\n`));

        for (const warning of evaluateDataLossResult.warnings) {
          console.log(`  • ${warning.message}`);
        }
      }

      console.log(); // for an empty line

      let migrationName = await getMigrationName(); // note this only creates the migration, it does not apply it

      let {
        generatedMigrationName
      } = await runMigrateWithDbUrl(dbUrl, () => migrate.createMigration({
        migrationsDirectoryPath: migrate.migrationsDirectoryPath,
        // https://github.com/prisma/prisma-engines/blob/11dfcc85d7f9b55235e31630cd87da7da3aed8cc/migration-engine/core/src/commands/create_migration.rs#L16-L17
        // draft means "create an empty migration even if there are no changes rather than exiting"
        // because this whole thing only happens when there are changes to the schema, this can be false
        // (we should also ofc have a way to create an empty migration but that's a separate thing)
        draft: false,
        prismaSchema,
        migrationName
      }));
      console.log(`✨ A migration has been created at .keystone/prisma/migrations/${generatedMigrationName}`);
      let shouldApplyMigration = migrationCanBeApplied && (await confirmPrompt('Would you like to apply this migration?'));

      if (shouldApplyMigration) {
        await runMigrateWithDbUrl(dbUrl, () => migrate.applyMigrations());
        console.log('✅ The migration has been applied');
      } else {
        console.log('Please edit the migration and run keystone-next dev again to apply the migration');
        process.exit(0);
      }
    } else {
      if (appliedMigrationNames.length) {
        console.log('✨ Your migrations are up to date, no new migrations need to be created');
      } else {
        console.log('✨ Your database is up to date, no migrations need to be created or applied');
      }
    }
  });
} // based on https://github.com/prisma/prisma/blob/3fed5919545bfae0a82d35134a4f1d21359118cb/src/packages/migrate/src/utils/promptForMigrationName.ts

const MAX_MIGRATION_NAME_LENGTH = 200;

async function getMigrationName() {
  let migrationName = await textPrompt('Name of migration');
  return slugify(migrationName, {
    separator: '_'
  }).substring(0, MAX_MIGRATION_NAME_LENGTH);
}

function printFilesFromMigrationIds(migrationIds) {
  return `.keystone/prisma/migrations/\n${migrationIds.map(migrationId => `  └─ ${printMigrationId(migrationId)}/\n    └─ migration.sql`).join('\n')}`;
}

function printMigrationId(migrationId) {
  const words = migrationId.split('_');

  if (words.length === 1) {
    return chalk.cyan.bold(migrationId);
  }

  return `${words[0]}_${chalk.cyan.bold(words.slice(1).join('_'))}`;
}

async function ensureDatabaseExists(dbUrl, schemaDir) {
  // createDatabase will return false when the database already exists
  const result = await createDatabase(dbUrl, schemaDir);

  if (result && result.exitCode === 0) {
    const credentials = uriToCredentials(dbUrl);
    console.log(`✨ ${credentials.type} database "${credentials.database}" created at ${getDbLocation(credentials)}`);
  } // TODO: handle createDatabase returning a failure (prisma's cli does not handle it though so not super worried)

}

function getDbLocation(credentials) {
  if (credentials.type === 'sqlite') {
    return credentials.uri;
  }

  return `${credentials.host}${credentials.port === undefined ? '' : `:${credentials.port}`}`;
}

function formatms(ms) {
  if (ms < 1000) {
    return `${ms}ms`;
  }

  return (ms / 1000).toFixed(2) + 's';
}

class PrismaAdapter extends BaseKeystoneAdapter {
  constructor(config = {}) {
    super(...arguments);
    this._prismaClient = config.prismaClient;
    this.listAdapterClass = PrismaListAdapter;
    this.name = 'prisma';
    this.provider = this.config.provider || 'postgresql';
    this.migrationMode = this.config.migrationMode || 'prototype';

    this.getPrismaPath = this.config.getPrismaPath || (() => '.prisma');

    this.getDbSchemaName = this.config.getDbSchemaName || (() => 'public');

    this.enableLogging = this.config.enableLogging || false;
    this.url = this.config.url || process.env.DATABASE_URL;
  }

  async _prepareSchema(rels) {
    const clientDir = 'generated-client';
    const prismaSchema = await this._generatePrismaSchema({
      rels,
      clientDir
    }); // See if there is a prisma client available for this hash

    const prismaPath = this.getPrismaPath({
      prismaSchema
    });
    this.schemaPath = path.join(prismaPath, 'schema.prisma');
    this.clientPath = path.resolve(`${prismaPath}/${clientDir}`);
    this.dbSchemaName = this.getDbSchemaName({
      prismaSchema
    });
    this.prismaSchema = prismaSchema;
    return {
      prismaSchema
    };
  }

  _url() {
    // By default we put `schema=public` onto all `DATABASE_URL` values.
    // If this isn't what a user wants, they can update `getSchemaName` to return either
    // a different dbSchemaName, or null if they just want to use the DATABASE_URL as it is.
    // TODO: Should we default to 'public' or null?
    if (this.provider === 'postgresql') {
      return this.dbSchemaName ? `${this.url}?schema=${this.dbSchemaName}` : this.url;
    } else if (this.provider === 'sqlite') {
      return this.url;
    }
  }

  async deploy(rels) {
    // Apply any migrations which haven't already been applied
    await this._prepareSchema(rels);
    await deployMigrations(this._url(), path.resolve(this.schemaPath));
  }

  async _getPrismaClient({
    rels
  }) {
    if (this._prismaClient) {
      return this._prismaClient;
    }

    await this._generateClient(rels);
    return require(this.clientPath).PrismaClient;
  }

  async _connect({
    rels
  }) {
    // the adapter was already connected since we have a prisma client
    // it may have been disconnected since it was connected though
    // so connect but don't regenerate the prisma client
    if (this.prisma) {
      await this.prisma.$connect();
      return;
    }

    const PrismaClient = await this._getPrismaClient({
      rels
    });
    this.prisma = new PrismaClient({
      log: this.enableLogging && ['query'],
      datasources: {
        [this.provider]: {
          url: this._url()
        }
      }
    });
    await this.prisma.$connect();
  }

  async _generateClient(rels) {
    // Generate a formatted schema
    // note that we currently still need to call _prepareSchema even during
    // a `keystone-next start` because it has various side effects
    const {
      prismaSchema
    } = await this._prepareSchema(rels);

    if (this.migrationMode !== 'none-skip-client-generation') {
      this._writePrismaSchema({
        prismaSchema
      }); // Generate prisma client and run prisma migrations


      await Promise.all([this._generatePrismaClient(), this._runMigrations({
        prismaSchema
      })]);
    }
  }

  async _runMigrations({
    prismaSchema
  }) {
    if (this.migrationMode === 'prototype') {
      // Sync the database directly, without generating any migration
      await runPrototypeMigrations(this._url(), prismaSchema, path.resolve(this.schemaPath));
    } else if (this.migrationMode === 'dev') {
      // Generate and apply a migration if required.
      await devMigrations(this._url(), prismaSchema, path.resolve(this.schemaPath));
    } else if (this.migrationMode === 'none') ; else {
      throw new Error(`migrationMode must be one of 'dev', 'prototype', 'none-skip-client-generation', or 'none`);
    }
  }

  async _writePrismaSchema({
    prismaSchema
  }) {
    // Make output dir (you know, just in case!)
    fs.mkdirSync(this.clientPath, {
      recursive: true
    }); // Write prisma file

    fs.writeSync(fs.openSync(this.schemaPath, 'w'), prismaSchema);
  }

  async _generatePrismaClient() {
    const generator = await getGenerator({
      schemaPath: this.schemaPath
    });
    await generator.generate();
    generator.stop();
  }

  async _generatePrismaSchema({
    rels,
    clientDir
  }) {
    const models = Object.values(this.listAdapters).map(listAdapter => {
      const scalarFields = flatten(listAdapter.fieldAdapters.filter(f => !f.field.isRelationship).map(f => f.getPrismaSchema()));
      const relFields = [...flatten(listAdapter.fieldAdapters.map(({
        field
      }) => field).filter(f => f.isRelationship).map(f => {
        const r = rels.find(r => r.left === f || r.right === f);
        const isLeft = r.left === f;

        if (r.cardinality === 'N:N') {
          const relName = r.tableName;
          return [`${f.path} ${f.refListKey}[] @relation("${relName}", references: [id])`];
        } else {
          const relName = `${r.tableName}${r.columnName}`;

          if (r.cardinality === 'N:1' && isLeft || r.cardinality === '1:N' && !isLeft || r.cardinality === '1:1' && isLeft) {
            // We're the owner of the foreign key column
            return [`${f.path} ${f.refListKey}? @relation("${relName}", fields: [${f.path}Id], references: [id])`, `${f.path}Id Int? @map("${r.columnName}")`];
          } else if (r.cardinality === '1:1') {
            return [`${f.path} ${f.refListKey}? @relation("${relName}")`];
          } else {
            return [`${f.path} ${f.refListKey}[] @relation("${relName}")`];
          }
        }
      })), ...flatten(rels.filter(({
        right
      }) => !right).filter(({
        left
      }) => left.refListKey === listAdapter.key).filter(({
        cardinality
      }) => cardinality === 'N:N').map(({
        left: {
          path,
          listKey
        },
        tableName
      }) => [`from_${listKey}_${path} ${listKey}[] @relation("${tableName}", references: [id])`])), ...flatten(rels.filter(({
        right
      }) => !right).filter(({
        left
      }) => left.refListKey === listAdapter.key).filter(({
        cardinality
      }) => cardinality === '1:N' || cardinality === 'N:1').map(({
        left: {
          path,
          listKey
        },
        tableName,
        columnName
      }) => [`from_${listKey}_${path} ${listKey}[] @relation("${tableName}${columnName}")`]))];
      const indexes = flatten(listAdapter.fieldAdapters.map(({
        field
      }) => field).filter(f => f.isRelationship).map(f => {
        const r = rels.find(r => r.left === f || r.right === f);
        const isLeft = r.left === f;

        if (r.cardinality === 'N:1' && isLeft || r.cardinality === '1:N' && !isLeft || r.cardinality === '1:1' && isLeft) {
          return [`@@index([${f.path}Id])`];
        }

        return [];
      }));
      return `
        model ${listAdapter.key} {
          ${[...scalarFields, ...relFields, ...indexes].join('\n  ')}
        }`;
    });
    const enums = flatten(Object.values(this.listAdapters).map(listAdapter => flatten(listAdapter.fieldAdapters.filter(f => !f.field.isRelationship).filter(f => f.path !== 'id').map(f => f.getPrismaEnums()))));
    const header = `
      datasource ${this.provider} {
        url      = env("DATABASE_URL")
        provider = "${this.provider}"
      }
      generator client {
        provider = "prisma-client-js"
        output = "${clientDir}"
      }`;
    return await formatSchema({
      schema: header + models.join('\n') + '\n' + enums.join('\n')
    });
  }

  async postConnect({
    rels
  }) {
    Object.values(this.listAdapters).forEach(listAdapter => {
      listAdapter._postConnect({
        rels,
        prisma: this.prisma
      });
    });

    if (this.config.dropDatabase && process.env.NODE_ENV !== 'production') {
      await this.dropDatabase();
    }

    return [];
  } // This will drop all the tables in the backing database. Use wisely.


  async dropDatabase() {
    if (this.migrationMode === 'prototype') {
      if (this.provider === 'postgresql') {
        // Special fast path to drop data from a postgres database.
        // This is an optimization which is particularly crucial in a unit testing context.
        // This code path takes milliseconds, vs ~7 seconds for a migrate reset + db push
        for (const {
          tablename
        } of await this.prisma.$queryRaw(`SELECT tablename FROM pg_tables WHERE schemaname='${this.dbSchemaName}'`)) {
          await this.prisma.$queryRaw(`TRUNCATE TABLE \"${this.dbSchemaName}\".\"${tablename}\" CASCADE;`);
        }

        for (const {
          relname
        } of await this.prisma.$queryRaw(`SELECT c.relname FROM pg_class AS c JOIN pg_namespace AS n ON c.relnamespace = n.oid WHERE c.relkind='S' AND n.nspname='${this.dbSchemaName}';`)) {
          await this.prisma.$queryRaw(`ALTER SEQUENCE \"${this.dbSchemaName}\".\"${relname}\" RESTART WITH 1;`);
        }
      } else if (this.provider === 'sqlite') {
        const tables = await this.prisma.$queryRaw("SELECT name FROM sqlite_master WHERE type='table';");

        for (const {
          name
        } of tables) {
          await this.prisma.$queryRaw(`DELETE FROM "${name}";`);
        }
      } else {
        throw new Error('Only "postgresql" and "sqlite" providers are supported');
      }
    } else {
      resetDatabaseWithMigrations(this._url(), path.resolve(this.schemaPath));
    }
  }

  disconnect() {
    return this.prisma.$disconnect();
  }

  getDefaultPrimaryKeyConfig() {
    // Required here due to circular refs
    const {
      AutoIncrement
    } = require('@keystone-next/fields-auto-increment-legacy');

    return AutoIncrement.primaryKeyDefaults[this.name].getConfig();
  }

  async checkDatabaseVersion() {// FIXME: Decide what/how we want to check things here
  }

}

class PrismaListAdapter extends BaseListAdapter {
  constructor(key, parentAdapter) {
    super(...arguments);
    this.getListAdapterByKey = parentAdapter.getListAdapterByKey.bind(parentAdapter);
  }

  _postConnect({
    rels,
    prisma
  }) {
    // https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-schema/models#queries-crud
    // "By default the name of the property is the lowercase form of the model name,
    // e.g. user for a User model or post for a Post model."
    this.model = prisma[this.key.slice(0, 1).toLowerCase() + this.key.slice(1)];
    this.fieldAdapters.forEach(fieldAdapter => {
      fieldAdapter.rel = rels.find(({
        left,
        right
      }) => left.adapter === fieldAdapter || right && right.adapter === fieldAdapter);
    });
  } ////////// Mutations //////////


  _include() {
    // We don't have a "real key" (i.e. a column in the table) if:
    //  * We're a N:N
    //  * We're the right hand side of a 1:1
    //  * We're the 1 side of a 1:N or N:1 (e.g we are the one with config: many)
    const include = defaultObj(this.fieldAdapters.filter(({
      isRelationship
    }) => isRelationship).filter(a => a.config.many || a.rel.cardinality === '1:1' && a.rel.right.adapter === a).map(a => a.path), {
      select: {
        id: true
      }
    });
    return Object.keys(include).length > 0 ? include : undefined;
  }

  async _create(_data) {
    return this.model.create({
      data: mapKeys(_data, (value, path) => this.fieldAdaptersByPath[path] && this.fieldAdaptersByPath[path].isRelationship ? {
        connect: Array.isArray(value) ? value.map(x => ({
          id: Number(x)
        })) : {
          id: Number(value)
        }
      } : this.fieldAdaptersByPath[path] && this.fieldAdaptersByPath[path].gqlToPrisma ? this.fieldAdaptersByPath[path].gqlToPrisma(value) : value),
      include: this._include()
    });
  }

  async _update(id, _data) {
    const include = this._include();

    const existingItem = await this.model.findUnique({
      where: {
        id: Number(id)
      },
      include
    });
    return this.model.update({
      where: {
        id: Number(id)
      },
      data: mapKeys(_data, (value, path) => {
        if (this.fieldAdaptersByPath[path] && this.fieldAdaptersByPath[path].isRelationship && Array.isArray(value)) {
          const vs = value.map(x => Number(x));
          const toDisconnect = existingItem[path].filter(({
            id
          }) => !vs.includes(id));
          const toConnect = vs.filter(id => !existingItem[path].map(({
            id
          }) => id).includes(id)).map(id => ({
            id
          }));
          return {
            disconnect: toDisconnect.length ? toDisconnect : undefined,
            connect: toConnect.length ? toConnect : undefined
          };
        }

        return this.fieldAdaptersByPath[path] && this.fieldAdaptersByPath[path].isRelationship ? value === null ? {
          disconnect: true
        } : {
          connect: {
            id: Number(value)
          }
        } : value;
      }),
      include
    });
  }

  async _delete(id) {
    return this.model.delete({
      where: {
        id: Number(id)
      }
    });
  } ////////// Queries //////////


  async _itemsQuery(args, {
    meta = false,
    from = {}
  } = {}) {
    const filter = this.prismaFilter({
      args,
      meta,
      from
    });

    if (meta) {
      let count = await this.model.count(filter);
      const {
        first,
        skip
      } = args; // Adjust the count as appropriate

      if (skip !== undefined) {
        count -= skip;
      }

      if (first !== undefined) {
        count = Math.min(count, first);
      }

      count = Math.max(0, count); // Don't want to go negative from a skip!

      return {
        count
      };
    } else {
      return this.model.findMany(filter);
    }
  }

  prismaFilter({
    args: {
      where = {},
      first,
      skip,
      sortBy,
      orderBy,
      search
    },
    meta,
    from
  }) {
    const ret = {};
    const allWheres = this.processWheres(where);

    if (allWheres) {
      ret.where = allWheres;
    }

    if (from.fromId) {
      if (!ret.where) {
        ret.where = {};
      }

      const a = from.fromList.adapter.fieldAdaptersByPath[from.fromField];

      if (a.rel.cardinality === 'N:N') {
        const path = a.rel.right ? a.field === a.rel.right // Two-sided
        ? a.rel.left.path : a.rel.right.path : `from_${a.rel.left.listKey}_${a.rel.left.path}`; // One-sided

        ret.where[path] = {
          some: {
            id: Number(from.fromId)
          }
        };
      } else {
        ret.where[a.rel.columnName] = {
          id: Number(from.fromId)
        };
      }
    } // TODO: Implement configurable search fields for lists


    const searchFieldName = this.config.searchField || 'name';
    const searchField = this.fieldAdaptersByPath[searchFieldName];

    if (search !== undefined && search !== '' && searchField) {
      if (searchField.fieldName === 'Text') {
        // FIXME: Think about regex
        const mode = this.parentAdapter.provider === 'sqlite' ? undefined : 'insensitive';

        if (!ret.where) {
          ret.where = {
            [searchFieldName]: {
              contains: search,
              mode
            }
          };
        } else {
          ret.where = {
            AND: [ret.where, {
              [searchFieldName]: {
                contains: search,
                mode
              }
            }]
          };
        } // const f = escapeRegExp;
        // this._query.andWhere(`${baseTableAlias}.${searchFieldName}`, '~*', f(search));

      } else {
        // Return no results
        if (!ret.where) {
          ret.where = {
            AND: [{
              [searchFieldName]: null
            }, {
              NOT: {
                [searchFieldName]: null
              }
            }]
          };
        } else {
          ret.where = {
            AND: [ret.where, {
              [searchFieldName]: null
            }, {
              NOT: {
                [searchFieldName]: null
              }
            }]
          };
        }
      }
    } // Add query modifiers as required


    if (!meta) {
      if (first !== undefined) {
        // SELECT ... LIMIT <first>
        ret.take = first;
      }

      if (skip !== undefined) {
        // SELECT ... OFFSET <skip>
        ret.skip = skip;
      }

      if (orderBy !== undefined) {
        // SELECT ... ORDER BY <orderField>
        const [orderField, orderDirection] = orderBy.split('_');
        const sortKey = this.fieldAdaptersByPath[orderField].sortKey || orderField;
        ret.orderBy = {
          [sortKey]: orderDirection.toLowerCase()
        };
      }

      if (sortBy !== undefined) {
        // SELECT ... ORDER BY <orderField>[, <orderField>, ...]
        if (!ret.orderBy) ret.orderBy = {};
        sortBy.forEach(s => {
          const [orderField, orderDirection] = s.split('_');
          const sortKey = this.fieldAdaptersByPath[orderField].sortKey || orderField;
          ret.orderBy[sortKey] = orderDirection.toLowerCase();
        });
      }

      this.fieldAdapters.filter(a => a.isRelationship && a.rel.cardinality === '1:1' && a.rel.right === a.field).forEach(({
        path
      }) => {
        if (!ret.include) ret.include = {};
        ret.include[path] = true;
      });
    }

    return ret;
  }

  processWheres(where) {
    const processRelClause = (fieldPath, clause) => this.getListAdapterByKey(this.fieldAdaptersByPath[fieldPath].refListKey).processWheres(clause);

    const wheres = Object.entries(where).map(([condition, value]) => {
      if (condition === 'AND' || condition === 'OR') {
        return {
          [condition]: value.map(w => this.processWheres(w))
        };
      } else if (this.fieldAdaptersByPath[condition] && this.fieldAdaptersByPath[condition].isRelationship) {
        // Non-many relationship. Traverse the sub-query, using the referenced list as a root.
        return {
          [condition]: processRelClause(condition, value)
        };
      } else {
        // See if any of our fields know what to do with this condition
        let dbPath = condition;
        let fieldAdapter = this.fieldAdaptersByPath[dbPath];

        while (!fieldAdapter && dbPath.includes('_')) {
          dbPath = dbPath.split('_').slice(0, -1).join('_');
          fieldAdapter = this.fieldAdaptersByPath[dbPath];
        } // FIXME: ask the field adapter if it supports the condition type


        const supported = fieldAdapter && fieldAdapter.getQueryConditions(fieldAdapter.dbPath)[condition];

        if (supported) {
          return supported(value);
        } else {
          // Many relationship
          const [fieldPath, constraintType] = condition.split('_');
          return {
            [fieldPath]: {
              [constraintType]: processRelClause(fieldPath, value)
            }
          };
        }
      }
    });
    return wheres.length === 0 ? undefined : wheres.length === 1 ? wheres[0] : {
      AND: wheres
    };
  }

}

class PrismaFieldAdapter extends BaseFieldAdapter {
  constructor() {
    super(...arguments);
  }

  _schemaField({
    type,
    extra = ''
  }) {
    const {
      isRequired,
      isUnique
    } = this.config;
    return `${this.path} ${type}${isRequired || this.field.isPrimaryKey ? '' : '?'} ${this.field.isPrimaryKey ? '@id' : ''} ${isUnique && !this.field.isPrimaryKey ? '@unique' : ''} ${extra}`;
  }

  getPrismaSchema() {
    return [this._schemaField({
      type: 'String'
    })];
  }

  getPrismaEnums() {
    return [];
  } // The following methods provide helpers for constructing the return values of `getQueryConditions`.
  // Each method takes:
  //   `dbPath`: The database field/column name to be used in the comparison
  //   `f`: (non-string methods only) A value transformation function which converts from a string type
  //        provided by graphQL into a native adapter type.


  equalityConditions(dbPath, f = identity) {
    return {
      [this.path]: value => ({
        [dbPath]: {
          equals: f(value)
        }
      }),
      [`${this.path}_not`]: value => value === null ? {
        NOT: {
          [dbPath]: {
            equals: f(value)
          }
        }
      } : {
        OR: [{
          NOT: {
            [dbPath]: {
              equals: f(value)
            }
          }
        }, {
          [dbPath]: {
            equals: null
          }
        }]
      }
    };
  }

  equalityConditionsInsensitive(dbPath, f = identity) {
    return {
      [`${this.path}_i`]: value => ({
        [dbPath]: {
          equals: f(value),
          mode: 'insensitive'
        }
      }),
      [`${this.path}_not_i`]: value => value === null ? {
        NOT: {
          [dbPath]: {
            equals: f(value),
            mode: 'insensitive'
          }
        }
      } : {
        OR: [{
          NOT: {
            [dbPath]: {
              equals: f(value),
              mode: 'insensitive'
            }
          }
        }, {
          [dbPath]: null
        }]
      }
    };
  }

  inConditions(dbPath, f = identity) {
    return {
      [`${this.path}_in`]: value => value.includes(null) ? {
        OR: [{
          [dbPath]: {
            in: value.filter(x => x !== null).map(f)
          }
        }, {
          [dbPath]: null
        }]
      } : {
        [dbPath]: {
          in: value.map(f)
        }
      },
      [`${this.path}_not_in`]: value => value.includes(null) ? {
        AND: [{
          NOT: {
            [dbPath]: {
              in: value.filter(x => x !== null).map(f)
            }
          }
        }, {
          NOT: {
            [dbPath]: null
          }
        }]
      } : {
        OR: [{
          NOT: {
            [dbPath]: {
              in: value.map(f)
            }
          }
        }, {
          [dbPath]: null
        }]
      }
    };
  }

  orderingConditions(dbPath, f = identity) {
    return {
      [`${this.path}_lt`]: value => ({
        [dbPath]: {
          lt: f(value)
        }
      }),
      [`${this.path}_lte`]: value => ({
        [dbPath]: {
          lte: f(value)
        }
      }),
      [`${this.path}_gt`]: value => ({
        [dbPath]: {
          gt: f(value)
        }
      }),
      [`${this.path}_gte`]: value => ({
        [dbPath]: {
          gte: f(value)
        }
      })
    };
  }

  stringConditions(dbPath, f = identity) {
    return {
      [`${this.path}_contains`]: value => ({
        [dbPath]: {
          contains: f(value)
        }
      }),
      [`${this.path}_not_contains`]: value => ({
        OR: [{
          NOT: {
            [dbPath]: {
              contains: f(value)
            }
          }
        }, {
          [dbPath]: null
        }]
      }),
      [`${this.path}_starts_with`]: value => ({
        [dbPath]: {
          startsWith: f(value)
        }
      }),
      [`${this.path}_not_starts_with`]: value => ({
        OR: [{
          NOT: {
            [dbPath]: {
              startsWith: f(value)
            }
          }
        }, {
          [dbPath]: null
        }]
      }),
      [`${this.path}_ends_with`]: value => ({
        [dbPath]: {
          endsWith: f(value)
        }
      }),
      [`${this.path}_not_ends_with`]: value => ({
        OR: [{
          NOT: {
            [dbPath]: {
              endsWith: f(value)
            }
          }
        }, {
          [dbPath]: null
        }]
      })
    };
  }

  stringConditionsInsensitive(dbPath, f = identity) {
    return {
      [`${this.path}_contains_i`]: value => ({
        [dbPath]: {
          contains: f(value),
          mode: 'insensitive'
        }
      }),
      [`${this.path}_not_contains_i`]: value => ({
        OR: [{
          NOT: {
            [dbPath]: {
              contains: f(value),
              mode: 'insensitive'
            }
          }
        }, {
          [dbPath]: null
        }]
      }),
      [`${this.path}_starts_with_i`]: value => ({
        [dbPath]: {
          startsWith: f(value),
          mode: 'insensitive'
        }
      }),
      [`${this.path}_not_starts_with_i`]: value => ({
        OR: [{
          NOT: {
            [dbPath]: {
              startsWith: f(value),
              mode: 'insensitive'
            }
          }
        }, {
          [dbPath]: null
        }]
      }),
      [`${this.path}_ends_with_i`]: value => ({
        [dbPath]: {
          endsWith: f(value),
          mode: 'insensitive'
        }
      }),
      [`${this.path}_not_ends_with_i`]: value => ({
        OR: [{
          NOT: {
            [dbPath]: {
              endsWith: f(value),
              mode: 'insensitive'
            }
          }
        }, {
          [dbPath]: null
        }]
      })
    };
  }

}

export { PrismaAdapter, PrismaFieldAdapter, PrismaListAdapter, createMigration };
