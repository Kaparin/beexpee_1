'use strict';

var _objectSpread = require('@babel/runtime/helpers/objectSpread2');
var _objectWithoutProperties = require('@babel/runtime/helpers/objectWithoutProperties');
var graphql = require('graphql');
var utils = require('@graphql-tools/utils');
var schema = require('@graphql-tools/schema');
var system = require('@keystone-next/admin-ui/system');
var session_dist_keystone = require('../session/dist/keystone.cjs.dev.js');
var serverSideGraphqlClientLegacy = require('@keystone-next/server-side-graphql-client-legacy');
var values = require('graphql/execution/values');
var path = require('path');
var keystoneLegacy = require('@keystone-next/keystone-legacy');
var adapterMongooseLegacy = require('@keystone-next/adapter-mongoose-legacy');
var adapterKnexLegacy = require('@keystone-next/adapter-knex-legacy');
var adapterPrismaLegacy = require('@keystone-next/adapter-prisma-legacy');
var cors = require('cors');
var express = require('express');
var graphqlUpload = require('graphql-upload');
var apolloServerMicro = require('apollo-server-micro');
var apolloServerExpress = require('apollo-server-express');
var formatError = require('@keystone-next/keystone-legacy/lib/Keystone/format-error');
var fields = require('@keystone-next/fields');

function _interopDefault (e) { return e && e.__esModule ? e : { 'default': e }; }

var path__default = /*#__PURE__*/_interopDefault(path);
var cors__default = /*#__PURE__*/_interopDefault(cors);
var express__default = /*#__PURE__*/_interopDefault(express);

function createGraphQLSchema(config, keystone, schemaName = 'public') {
  // Start with the core keystone graphQL schema
  let graphQLSchema = schema.makeExecutableSchema({
    typeDefs: keystone.getTypeDefs({
      schemaName
    }),
    resolvers: keystone.getResolvers({
      schemaName
    })
  }); // Filter out the _label_ field from all lists

  graphQLSchema = utils.mapSchema(graphQLSchema, {
    'MapperKind.OBJECT_TYPE'(type) {
      if (config.lists[type.name] !== undefined && config.lists[type.name].fields._label_ === undefined) {
        let _type$toConfig = type.toConfig(),
            fields = _objectWithoutProperties(_type$toConfig.fields, ["_label_"]),
            objectTypeConfig = _objectWithoutProperties(_type$toConfig, ["fields"]);

        return new graphql.GraphQLObjectType(_objectSpread({
          fields
        }, objectTypeConfig));
      }

      return type;
    }

  }); // TODO: find a way to not pass keystone in here, if we can - it's too broad and makes
  // everything in the keystone instance public API
  // Merge in the user defined graphQL API

  if (config.extendGraphqlSchema) {
    graphQLSchema = config.extendGraphqlSchema(graphQLSchema, keystone);
  } // Merge in session graphQL API


  if (config.session) {
    graphQLSchema = session_dist_keystone.sessionSchema(graphQLSchema);
  } // Merge in the admin-meta graphQL API


  graphQLSchema = system.getAdminMetaSchema({
    keystone,
    config,
    schema: graphQLSchema
  });
  return graphQLSchema;
}

function getNamedOrListTypeNodeForType(type) {
  if (type instanceof graphql.GraphQLList) {
    return {
      kind: 'ListType',
      type: getTypeNodeForType(type.ofType)
    };
  }

  return {
    kind: 'NamedType',
    name: {
      kind: 'Name',
      value: type.name
    }
  };
}

function getTypeNodeForType(type) {
  if (type instanceof graphql.GraphQLNonNull) {
    return {
      kind: 'NonNullType',
      type: getNamedOrListTypeNodeForType(type.ofType)
    };
  }

  return getNamedOrListTypeNodeForType(type);
}

function getCoerceAndValidateArgumentsFnForGraphQLField(schema, field) {
  if (!field) return;
  const variableDefintions = [];

  for (const arg of field.args) {
    variableDefintions.push({
      kind: 'VariableDefinition',
      type: getTypeNodeForType(arg.type),
      variable: {
        kind: 'Variable',
        name: {
          kind: 'Name',
          value: `${arg.name}`
        }
      }
    });
  }

  const fieldNode = {
    kind: 'Field',
    name: {
      kind: 'Name',
      value: field.name
    },
    arguments: field.args.map(arg => ({
      kind: 'Argument',
      name: {
        kind: 'Name',
        value: arg.name
      },
      value: {
        kind: 'Variable',
        name: {
          kind: 'Name',
          value: `${arg.name}`
        }
      }
    }))
  };
  return args => {
    const coercedVariableValues = values.getVariableValues(schema, variableDefintions, args);

    if (coercedVariableValues.errors) {
      throw coercedVariableValues.errors[0];
    }

    return values.getArgumentValues(field, fieldNode, coercedVariableValues.coerced);
  };
}

function getArgsFactory(list, schema) {
  const queryFields = schema.getQueryType().getFields();
  const mutationFields = schema.getMutationType().getFields();
  const f = getCoerceAndValidateArgumentsFnForGraphQLField;
  return {
    findOne: f(schema, queryFields[list.gqlNames.itemQueryName]),
    findMany: f(schema, queryFields[list.gqlNames.listQueryName]),
    count: f(schema, queryFields[list.gqlNames.listQueryMetaName]),
    createOne: f(schema, mutationFields[list.gqlNames.createMutationName]),
    createMany: f(schema, mutationFields[list.gqlNames.createManyMutationName]),
    updateOne: f(schema, mutationFields[list.gqlNames.updateMutationName]),
    updateMany: f(schema, mutationFields[list.gqlNames.updateManyMutationName]),
    deleteOne: f(schema, mutationFields[list.gqlNames.deleteMutationName]),
    deleteMany: f(schema, mutationFields[list.gqlNames.deleteManyMutationName])
  };
}
function itemAPIForList(list, context, getArgs) {
  const listKey = list.key;
  return {
    findOne(_ref) {
      let {
        resolveFields = 'id'
      } = _ref,
          rawArgs = _objectWithoutProperties(_ref, ["resolveFields"]);

      if (!getArgs.findOne) throw new Error('You do not have access to this resource');
      const args = getArgs.findOne(rawArgs);

      if (resolveFields) {
        return serverSideGraphqlClientLegacy.getItem({
          listKey,
          context,
          returnFields: resolveFields,
          itemId: args.where.id
        });
      } else {
        return list.itemQuery(args, context);
      }
    },

    findMany(_ref2) {
      let {
        resolveFields = 'id'
      } = _ref2,
          rawArgs = _objectWithoutProperties(_ref2, ["resolveFields"]);

      if (!getArgs.findMany) throw new Error('You do not have access to this resource');
      const args = getArgs.findMany(rawArgs);

      if (resolveFields) {
        return serverSideGraphqlClientLegacy.getItems(_objectSpread({
          listKey,
          context,
          returnFields: resolveFields
        }, args));
      } else {
        return list.listQuery(args, context);
      }
    },

    async count(rawArgs) {
      if (!getArgs.count) throw new Error('You do not have access to this resource');
      const args = getArgs.count(rawArgs);
      return (await list.listQueryMeta(args, context)).getCount();
    },

    createOne(_ref3) {
      let {
        resolveFields = 'id'
      } = _ref3,
          rawArgs = _objectWithoutProperties(_ref3, ["resolveFields"]);

      if (!getArgs.createOne) throw new Error('You do not have access to this resource');
      const {
        data
      } = getArgs.createOne(rawArgs);

      if (resolveFields) {
        return serverSideGraphqlClientLegacy.createItem({
          listKey,
          context,
          returnFields: resolveFields,
          item: data
        });
      } else {
        return list.createMutation(data, context);
      }
    },

    createMany(_ref4) {
      let {
        resolveFields = 'id'
      } = _ref4,
          rawArgs = _objectWithoutProperties(_ref4, ["resolveFields"]);

      if (!getArgs.createMany) throw new Error('You do not have access to this resource');
      const {
        data
      } = getArgs.createMany(rawArgs);

      if (resolveFields) {
        return serverSideGraphqlClientLegacy.createItems({
          listKey,
          context,
          returnFields: resolveFields,
          items: data
        });
      } else {
        return list.createManyMutation(data, context);
      }
    },

    updateOne(_ref5) {
      let {
        resolveFields = 'id'
      } = _ref5,
          rawArgs = _objectWithoutProperties(_ref5, ["resolveFields"]);

      if (!getArgs.updateOne) throw new Error('You do not have access to this resource');
      const {
        id,
        data
      } = getArgs.updateOne(rawArgs);

      if (resolveFields) {
        return serverSideGraphqlClientLegacy.updateItem({
          listKey,
          context,
          returnFields: resolveFields,
          item: {
            id,
            data
          }
        });
      } else {
        return list.updateMutation(id, data, context);
      }
    },

    updateMany(_ref6) {
      let {
        resolveFields = 'id'
      } = _ref6,
          rawArgs = _objectWithoutProperties(_ref6, ["resolveFields"]);

      if (!getArgs.updateMany) throw new Error('You do not have access to this resource');
      const {
        data
      } = getArgs.updateMany(rawArgs);

      if (resolveFields) {
        return serverSideGraphqlClientLegacy.updateItems({
          listKey,
          context,
          returnFields: resolveFields,
          items: data
        });
      } else {
        return list.updateManyMutation(data, context);
      }
    },

    deleteOne(_ref7) {
      let {
        resolveFields = 'id'
      } = _ref7,
          rawArgs = _objectWithoutProperties(_ref7, ["resolveFields"]);

      if (!getArgs.deleteOne) throw new Error('You do not have access to this resource');
      const {
        id
      } = getArgs.deleteOne(rawArgs);

      if (resolveFields) {
        return serverSideGraphqlClientLegacy.deleteItem({
          listKey,
          context,
          returnFields: resolveFields,
          itemId: id
        });
      } else {
        return list.deleteMutation(id, context);
      }
    },

    deleteMany(_ref8) {
      let {
        resolveFields = 'id'
      } = _ref8,
          rawArgs = _objectWithoutProperties(_ref8, ["resolveFields"]);

      if (!getArgs.deleteMany) throw new Error('You do not have access to this resource');
      const {
        ids
      } = getArgs.deleteMany(rawArgs);

      if (resolveFields) {
        return serverSideGraphqlClientLegacy.deleteItems({
          listKey,
          context,
          returnFields: resolveFields,
          items: ids
        });
      } else {
        return list.deleteManyMutation(ids, context);
      }
    }

  };
}

async function validateListAccessControl(_ref) {
  let {
    access,
    operation,
    listKey
  } = _ref,
      args = _objectWithoutProperties(_ref, ["access", "operation", "listKey"]);

  // Either a boolean or an object describing a where clause
  let result;

  if (typeof access[operation] !== 'function') {
    result = access[operation];
  } else {
    result = await access[operation](_objectSpread({
      listKey,
      operation
    }, args));
  }

  const type = typeof result;

  if (!['object', 'boolean'].includes(type) || result === null) {
    throw new Error(`Must return an Object or Boolean from Imperative or Declarative access control function. Got ${type}`);
  } // Special case for 'create' permission


  if (operation === 'create' && type === 'object') {
    throw new Error(`Expected a Boolean for ${listKey}.access.create(), but got Object. (NOTE: 'create' cannot have a Declarative access control config)`);
  }

  return result;
}

async function validateFieldAccessControl(_ref2) {
  let {
    access,
    operation,
    listKey,
    fieldKey
  } = _ref2,
      args = _objectWithoutProperties(_ref2, ["access", "operation", "listKey", "fieldKey"]);

  let result;

  if (typeof access[operation] !== 'function') {
    result = access[operation];
  } else {
    result = await access[operation](_objectSpread({
      listKey,
      fieldKey,
      operation
    }, args));
  }

  if (typeof result !== 'boolean') {
    throw new Error(`Must return a Boolean from ${listKey}.fields.${fieldKey}.access.${operation}(). Got ${typeof result}`);
  }

  return result;
}

const skipAccessControlContext = {
  getListAccessControlForUser: () => true,
  getFieldAccessControlForUser: () => true
}; // these are memoized in current Keystone but not here
// since it's useless because all of the callers of them pass in new objects
// + the functions will never be called with the same stuff (even ignoring the identity of the objects mentioned above)
// + the memoization library used has a cache size of 1 by default

const accessControlContext = {
  async getListAccessControlForUser(access, listKey, originalInput, operation, {
    gqlName,
    itemId,
    itemIds,
    context
  }) {
    return validateListAccessControl({
      access: access[context.schemaName],
      originalInput,
      operation,
      session: context.session,
      listKey,
      gqlName,
      itemId,
      itemIds,
      context
    });
  },

  async getFieldAccessControlForUser(access, listKey, fieldKey, originalInput, item, operation, {
    gqlName,
    context
  }) {
    return validateFieldAccessControl({
      access: access[context.schemaName],
      originalInput,
      item,
      operation,
      session: context.session,
      fieldKey,
      listKey,
      gqlName,
      context
    });
  }

};

function makeCreateContext({
  graphQLSchema,
  internalSchema,
  keystone
}) {
  // We precompute these helpers here rather than every time createContext is called
  // because they require parsing the entire schema, which is potentially expensive.
  const publicGetArgsByList = {};

  for (const [listKey, list] of Object.entries(keystone.lists)) {
    publicGetArgsByList[listKey] = getArgsFactory(list, graphQLSchema);
  }

  const internalGetArgsByList = {};

  for (const [listKey, list] of Object.entries(keystone.lists)) {
    internalGetArgsByList[listKey] = getArgsFactory(list, internalSchema);
  }

  const createContext = ({
    sessionContext,
    skipAccessControl = false,
    req,
    schemaName = 'public'
  } = {}) => {
    const schema = schemaName === 'public' ? graphQLSchema : internalSchema;

    const rawGraphQL = ({
      query,
      variables
    }) => {
      const source = typeof query === 'string' ? query : graphql.print(query);
      return Promise.resolve(graphql.graphql({
        schema,
        source,
        contextValue: contextToReturn,
        variableValues: variables
      }));
    };

    const runGraphQL = async ({
      query,
      variables
    }) => {
      var _result$errors;

      let result = await rawGraphQL({
        query,
        variables
      });

      if ((_result$errors = result.errors) !== null && _result$errors !== void 0 && _result$errors.length) {
        throw result.errors[0];
      }

      return result.data;
    };

    const itemAPI = {};

    const contextToReturn = _objectSpread(_objectSpread(_objectSpread({
      schemaName
    }, skipAccessControl ? skipAccessControlContext : accessControlContext), {}, {
      lists: itemAPI,
      totalResults: 0,
      keystone,
      // Only one of these will be available on any given context
      // TODO: Capture that in the type
      knex: keystone.adapter.knex,
      mongoose: keystone.adapter.mongoose,
      prisma: keystone.adapter.prisma,
      graphql: {
        raw: rawGraphQL,
        run: runGraphQL,
        schema
      },
      maxTotalResults: keystone.queryLimits.maxTotalResults,
      sudo: () => createContext({
        sessionContext,
        skipAccessControl: true,
        req,
        schemaName: 'internal'
      }),
      exitSudo: () => createContext({
        sessionContext,
        skipAccessControl: false,
        req
      }),
      withSession: session => createContext({
        sessionContext: _objectSpread(_objectSpread({}, sessionContext), {}, {
          session
        }),
        skipAccessControl,
        req
      }),
      req
    }, sessionContext), {}, {
      // Note: These two fields let us use the server-side-graphql-client library.
      // We may want to remove them once the updated itemAPI w/ resolveFields is available.
      executeGraphQL: rawGraphQL,
      gqlNames: listKey => keystone.lists[listKey].gqlNames
    });

    const getArgsByList = schemaName === 'public' ? publicGetArgsByList : internalGetArgsByList;

    for (const [listKey, list] of Object.entries(keystone.lists)) {
      itemAPI[listKey] = itemAPIForList(list, contextToReturn, getArgsByList[listKey]);
    }

    return contextToReturn;
  };

  return createContext;
}

function createKeystone(config, dotKeystonePath, migrationAction, prismaClient) {
  // Note: For backwards compatibility we may want to expose
  // this as a public API so that users can start their transition process
  // by using this pattern for creating their Keystone object before using
  // it in their existing custom servers or original CLI systems.
  const {
    db,
    graphql,
    lists
  } = config;
  let adapter;

  if (db.adapter === 'knex') {
    adapter = new adapterKnexLegacy.KnexAdapter({
      knexOptions: {
        connection: db.url
      },
      dropDatabase: db.dropDatabase
    });
  } else if (db.adapter === 'mongoose') {
    adapter = new adapterMongooseLegacy.MongooseAdapter(_objectSpread({
      mongoUri: db.url
    }, db.mongooseOptions));
  } else if (db.adapter === 'prisma_postgresql') {
    adapter = new adapterPrismaLegacy.PrismaAdapter(_objectSpread(_objectSpread({
      getPrismaPath: () => path__default['default'].join(dotKeystonePath, 'prisma'),
      migrationMode: migrationAction === 'dev' ? db.useMigrations ? 'dev' : 'prototype' : migrationAction,
      prismaClient
    }, db), {}, {
      provider: 'postgresql'
    }));
  } else if (db.adapter === 'prisma_sqlite') {
    var _config$experimental;

    if (!((_config$experimental = config.experimental) !== null && _config$experimental !== void 0 && _config$experimental.prismaSqlite)) {
      throw new Error('SQLite support is still experimental. You must set { experimental: { prismaSqlite: true } } in your config to use this feature.');
    }

    adapter = new adapterPrismaLegacy.PrismaAdapter(_objectSpread(_objectSpread({
      getPrismaPath: () => path__default['default'].join(dotKeystonePath, 'prisma'),
      prismaClient,
      migrationMode: migrationAction === 'dev' ? db.useMigrations ? 'dev' : 'prototype' : migrationAction
    }, db), {}, {
      provider: 'sqlite'
    }));
  } // @ts-ignore The @types/keystonejs__keystone package has the wrong type for KeystoneOptions


  const keystone = new keystoneLegacy.Keystone({
    adapter,
    queryLimits: graphql === null || graphql === void 0 ? void 0 : graphql.queryLimits,
    // @ts-ignore The @types/keystonejs__keystone package has the wrong type for KeystoneOptions
    onConnect: (keystone, {
      context
    } = {}) => {
      var _config$db$onConnect, _config$db;

      return (_config$db$onConnect = (_config$db = config.db).onConnect) === null || _config$db$onConnect === void 0 ? void 0 : _config$db$onConnect.call(_config$db, context);
    } // FIXME: Unsupported options: Need to work which of these we want to support with backwards
    // compatibility options.
    // defaultAccess

  });
  Object.entries(lists).forEach(([key, {
    fields,
    graphql,
    access,
    hooks,
    description,
    db
  }]) => {
    var _graphql$description;

    keystone.createList(key, {
      fields: Object.fromEntries(Object.entries(fields).map(([key, {
        type,
        config
      }]) => [key, _objectSpread({
        type
      }, config)])),
      access,
      queryLimits: graphql === null || graphql === void 0 ? void 0 : graphql.queryLimits,
      schemaDoc: (_graphql$description = graphql === null || graphql === void 0 ? void 0 : graphql.description) !== null && _graphql$description !== void 0 ? _graphql$description : description,
      listQueryName: graphql === null || graphql === void 0 ? void 0 : graphql.listQueryName,
      itemQueryName: graphql === null || graphql === void 0 ? void 0 : graphql.itemQueryName,
      hooks,
      adapterConfig: db // FIXME: Unsupported options: Need to work which of these we want to support with backwards
      // compatibility options.
      // adminDoc
      // labelResolver
      // labelField
      // adminConfig
      // label
      // singular
      // plural
      // path
      // cacheHint
      // plugins

    });
  });
  return keystone;
}

function createSystem(config, dotKeystonePath, migrationAction, prismaClient) {
  const keystone = createKeystone(config, dotKeystonePath, migrationAction, prismaClient);
  const graphQLSchema = createGraphQLSchema(config, keystone, 'public');
  const internalSchema = createGraphQLSchema(config, keystone, 'internal');
  const createContext = makeCreateContext({
    keystone,
    graphQLSchema,
    internalSchema
  });
  return {
    keystone,
    graphQLSchema,
    createContext
  };
}

const createApolloServerMicro = ({
  graphQLSchema,
  createContext,
  sessionStrategy,
  apolloConfig,
  connectionPromise
}) => {
  const context = async ({
    req,
    res
  }) => {
    await connectionPromise;
    return createContext({
      sessionContext: sessionStrategy ? await session_dist_keystone.createSessionContext(sessionStrategy, req, res, createContext) : undefined,
      req
    });
  };

  const serverConfig = _createApolloServerConfig({
    graphQLSchema,
    apolloConfig
  });

  return new apolloServerMicro.ApolloServer(_objectSpread(_objectSpread({}, serverConfig), {}, {
    context
  }));
};
const createApolloServerExpress = ({
  graphQLSchema,
  createContext,
  sessionStrategy,
  apolloConfig
}) => {
  const context = async ({
    req,
    res
  }) => createContext({
    sessionContext: sessionStrategy ? await session_dist_keystone.createSessionContext(sessionStrategy, req, res, createContext) : undefined,
    req
  });

  const serverConfig = _createApolloServerConfig({
    graphQLSchema,
    apolloConfig
  });

  return new apolloServerExpress.ApolloServer(_objectSpread(_objectSpread({}, serverConfig), {}, {
    context
  }));
};

const _createApolloServerConfig = ({
  graphQLSchema,
  apolloConfig
}) => {
  // Playground config
  const pp = apolloConfig === null || apolloConfig === void 0 ? void 0 : apolloConfig.playground;
  let playground;
  const settings = {
    'request.credentials': 'same-origin'
  };

  if (typeof pp === 'boolean' && !pp) {
    playground = undefined;
  } else if (typeof pp === 'undefined' || typeof pp === 'boolean') {
    playground = {
      settings
    };
  } else {
    playground = _objectSpread(_objectSpread({}, pp), {}, {
      settings: _objectSpread(_objectSpread({}, settings), pp.settings)
    });
  }

  return _objectSpread(_objectSpread({
    uploads: false,
    schema: graphQLSchema,
    formatError: formatError.formatError
  }, apolloConfig), {}, {
    // Carefully inject the playground
    playground // FIXME: Support for file handling configuration
    // maxFileSize: 200 * 1024 * 1024,
    // maxFiles: 5,

  });
};

const addApolloServer = ({
  server,
  graphQLSchema,
  createContext,
  sessionStrategy,
  apolloConfig
}) => {
  const apolloServer = createApolloServerExpress({
    graphQLSchema,
    createContext,
    sessionStrategy,
    apolloConfig
  });
  server.use(graphqlUpload.graphqlUploadExpress()); // FIXME: Support custom API path via config.graphql.path.
  // Note: Core keystone uses '/admin/api' as the default.

  apolloServer.applyMiddleware({
    app: server,
    path: '/api/graphql',
    cors: false
  });
};

const createExpressServer = async (config, graphQLSchema, createContext, dev, projectAdminPath, isVerbose = true) => {
  var _config$server, _config$graphql, _config$ui;

  const server = express__default['default']();

  if ((_config$server = config.server) !== null && _config$server !== void 0 && _config$server.cors) {
    // Setting config.server.cors = true will provide backwards compatible defaults
    // Otherwise, the user can provide their own config object to use
    const corsConfig = typeof config.server.cors === 'boolean' ? {
      origin: true,
      credentials: true
    } : config.server.cors;
    server.use(cors__default['default'](corsConfig));
  }

  const sessionStrategy = config.session ? config.session() : undefined;
  if (isVerbose) console.log('✨ Preparing GraphQL Server');
  addApolloServer({
    server,
    graphQLSchema,
    createContext,
    sessionStrategy,
    apolloConfig: (_config$graphql = config.graphql) === null || _config$graphql === void 0 ? void 0 : _config$graphql.apolloConfig
  });

  if ((_config$ui = config.ui) !== null && _config$ui !== void 0 && _config$ui.isDisabled) {
    if (isVerbose) console.log('✨ Skipping Admin UI app');
  } else {
    if (isVerbose) console.log('✨ Preparing Admin UI Next.js app');
    server.use(await system.createAdminUIServer(config.ui, createContext, dev, projectAdminPath, sessionStrategy));
  }

  return server;
};

/* Validate lists config and default the id field */

function applyIdFieldDefaults(config) {
  const lists = {};
  Object.keys(config.lists).forEach(key => {
    var _config$lists$key$idF, _idField$config$ui, _idField$config$ui2;

    const listConfig = config.lists[key];

    if (listConfig.fields.id) {
      throw new Error(`A field with the \`id\` path is defined in the fields object on the ${JSON.stringify(key)} list. This is not allowed, use the idField option instead.`);
    }

    let idField = (_config$lists$key$idF = config.lists[key].idField) !== null && _config$lists$key$idF !== void 0 ? _config$lists$key$idF : {
      mongoose: fields.mongoId({}),
      knex: fields.autoIncrement({}),
      prisma_postgresql: fields.autoIncrement({}),
      prisma_sqlite: fields.autoIncrement({})
    }[config.db.adapter];
    idField = _objectSpread(_objectSpread({}, idField), {}, {
      config: _objectSpread({
        ui: _objectSpread({
          createView: _objectSpread({
            fieldMode: 'hidden'
          }, (_idField$config$ui = idField.config.ui) === null || _idField$config$ui === void 0 ? void 0 : _idField$config$ui.createView),
          itemView: _objectSpread({
            fieldMode: 'hidden'
          }, (_idField$config$ui2 = idField.config.ui) === null || _idField$config$ui2 === void 0 ? void 0 : _idField$config$ui2.itemView)
        }, idField.config.ui)
      }, idField.config)
    });

    const fields$1 = _objectSpread({
      id: idField
    }, listConfig.fields);

    lists[key] = _objectSpread(_objectSpread({}, listConfig), {}, {
      fields: fields$1
    });
  });
  return lists;
}

/*
  This function executes the validation and other initialisation logic that
  needs to be run on Keystone Config before it can be used.
*/

function initConfig(config) {
  return _objectSpread(_objectSpread({}, config), {}, {
    lists: applyIdFieldDefaults(config)
  });
}

exports.createApolloServerMicro = createApolloServerMicro;
exports.createExpressServer = createExpressServer;
exports.createKeystone = createKeystone;
exports.createSystem = createSystem;
exports.initConfig = initConfig;
