'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var _objectSpread = require('@babel/runtime/helpers/objectSpread2');
var _objectWithoutProperties = require('@babel/runtime/helpers/objectWithoutProperties');
var merge = require('@graphql-tools/merge');
var cookie = require('cookie');
var Iron = require('@hapi/iron');
var uidSafe = require('uid-safe');
var schema = require('../../dist/schema-04f0aff6.cjs.prod.js');

function _interopDefault (e) { return e && e.__esModule ? e : { 'default': e }; }

function _interopNamespace(e) {
  if (e && e.__esModule) return e;
  var n = Object.create(null);
  if (e) {
    Object.keys(e).forEach(function (k) {
      if (k !== 'default') {
        var d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: function () {
            return e[k];
          }
        });
      }
    });
  }
  n['default'] = e;
  return Object.freeze(n);
}

var cookie__namespace = /*#__PURE__*/_interopNamespace(cookie);
var Iron__default = /*#__PURE__*/_interopDefault(Iron);

function generateSessionId() {
  return uidSafe.sync(24);
}

const TOKEN_NAME = 'keystonejs-session';
const MAX_AGE = 60 * 60 * 8; // 8 hours
// should we also accept httpOnly?

/* TODO:
  - [ ] We could support additional where input to validate item sessions (e.g an isEnabled boolean)
*/
function withItemData(createSession, fieldSelections = {}) {
  return () => {
    const _createSession = createSession(),
          {
      get
    } = _createSession,
          sessionStrategy = _objectWithoutProperties(_createSession, ["get"]);

    return _objectSpread(_objectSpread({}, sessionStrategy), {}, {
      get: async ({
        req,
        createContext
      }) => {
        const session = await get({
          req,
          createContext
        });
        const sudoContext = createContext({}).sudo();

        if (!session || !session.listKey || !session.itemId || !sudoContext.lists[session.listKey]) {
          return;
        } // NOTE: This is wrapped in a try-catch block because a "not found" result will currently
        // throw; I think this needs to be reviewed, but for now this prevents a system crash when
        // the session item is invalid


        try {
          // If no field selection is specified, just load the id. We still load the item,
          // because doing so validates that it exists in the database
          const item = await sudoContext.lists[session.listKey].findOne({
            where: {
              id: session.itemId
            },
            resolveFields: fieldSelections[session.listKey] || 'id'
          });
          return _objectSpread(_objectSpread({}, session), {}, {
            data: item
          });
        } catch (e) {
          // TODO: This swallows all errors, we need a way to differentiate between "not found" and
          // actual exceptions that should be thrown
          return;
        }
      }
    });
  };
}
function statelessSessions({
  secret,
  maxAge = MAX_AGE,
  path = '/',
  secure =         "production" === 'production',
  ironOptions = Iron__default['default'].defaults,
  domain
}) {
  return () => {
    if (!secret) {
      throw new Error('You must specify a session secret to use sessions');
    }

    if (secret.length < 32) {
      throw new Error('The session secret must be at least 32 characters long');
    }

    return {
      async get({
        req
      }) {
        if (!req.headers.cookie) return;
        let cookies = cookie__namespace.parse(req.headers.cookie);
        if (!cookies[TOKEN_NAME]) return;

        try {
          return await Iron__default['default'].unseal(cookies[TOKEN_NAME], secret, ironOptions);
        } catch (err) {}
      },

      async end({
        res
      }) {
        res.setHeader('Set-Cookie', cookie__namespace.serialize(TOKEN_NAME, '', {
          maxAge: 0,
          expires: new Date(),
          httpOnly: true,
          secure,
          path,
          sameSite: 'lax',
          domain
        }));
      },

      async start({
        res,
        data
      }) {
        let sealedData = await Iron__default['default'].seal(data, secret, _objectSpread(_objectSpread({}, ironOptions), {}, {
          ttl: maxAge * 1000
        }));
        res.setHeader('Set-Cookie', cookie__namespace.serialize(TOKEN_NAME, sealedData, {
          maxAge,
          expires: new Date(Date.now() + maxAge * 1000),
          httpOnly: true,
          secure,
          path,
          sameSite: 'lax',
          domain
        }));
        return sealedData;
      }

    };
  };
}
function storedSessions(_ref) {
  let {
    store: storeOption,
    maxAge = MAX_AGE
  } = _ref,
      statelessSessionsOptions = _objectWithoutProperties(_ref, ["store", "maxAge"]);

  return () => {
    let {
      get,
      start,
      end
    } = statelessSessions(_objectSpread(_objectSpread({}, statelessSessionsOptions), {}, {
      maxAge
    }))();
    let store = typeof storeOption === 'function' ? storeOption({
      maxAge
    }) : storeOption;
    let isConnected = false;
    return {
      async get({
        req,
        createContext
      }) {
        let sessionId = await get({
          req,
          createContext
        });

        if (typeof sessionId === 'string') {
          if (!isConnected) {
            var _store$connect;

            await ((_store$connect = store.connect) === null || _store$connect === void 0 ? void 0 : _store$connect.call(store));
            isConnected = true;
          }

          return store.get(sessionId);
        }
      },

      async start({
        res,
        data,
        createContext
      }) {
        let sessionId = generateSessionId();

        if (!isConnected) {
          var _store$connect2;

          await ((_store$connect2 = store.connect) === null || _store$connect2 === void 0 ? void 0 : _store$connect2.call(store));
          isConnected = true;
        }

        await store.set(sessionId, data);
        return (start === null || start === void 0 ? void 0 : start({
          res,
          data: {
            sessionId
          },
          createContext
        })) || '';
      },

      async end({
        req,
        res,
        createContext
      }) {
        let sessionId = await get({
          req,
          createContext
        });

        if (typeof sessionId === 'string') {
          if (!isConnected) {
            var _store$connect3;

            await ((_store$connect3 = store.connect) === null || _store$connect3 === void 0 ? void 0 : _store$connect3.call(store));
            isConnected = true;
          }

          await store.delete(sessionId);
        }

        await (end === null || end === void 0 ? void 0 : end({
          req,
          res,
          createContext
        }));
      }

    };
  };
}
/**
 * This is the function createSystem uses to implement the session strategy provided
 */

async function createSessionContext(sessionStrategy, req, res, createContext) {
  return {
    session: await sessionStrategy.get({
      req,
      createContext
    }),
    startSession: data => sessionStrategy.start({
      res,
      data,
      createContext
    }),
    endSession: () => sessionStrategy.end({
      req,
      res,
      createContext
    })
  };
}
function sessionSchema(graphQLSchema) {
  return merge.mergeSchemas({
    schemas: [graphQLSchema],
    typeDefs: schema.gql`
      type Mutation {
        endSession: Boolean!
      }
    `,
    resolvers: {
      Mutation: {
        async endSession(rootVal, args, context) {
          if (context.endSession) {
            await context.endSession();
          }

          return true;
        }

      }
    }
  });
}

exports.createSessionContext = createSessionContext;
exports.sessionSchema = sessionSchema;
exports.statelessSessions = statelessSessions;
exports.storedSessions = storedSessions;
exports.withItemData = withItemData;
