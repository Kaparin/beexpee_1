import path from 'path';
import meow from 'meow';
import express from 'express';
import { generateAdminUI, buildAdminUI } from '@keystone-next/admin-ui/system';
import { i as initConfig, c as createSystem, a as createExpressServer, d as createKeystone } from '../../dist/initConfig-a666b513.esm.js';
import _objectSpread from '@babel/runtime/helpers/esm/objectSpread2';
import { addHook } from 'pirates';
import * as babel from '@babel/core';
import sourceMapSupport from 'source-map-support';
import { parse, GraphQLScalarType, printSchema } from 'graphql';
import * as fs from 'fs-extra';
import fs__default, { outputFile } from 'fs-extra';
import prettier from 'prettier';
import { createMigration } from '@keystone-next/adapter-prisma-legacy';
import '@babel/runtime/helpers/objectWithoutProperties';
import '@graphql-tools/utils';
import '@graphql-tools/schema';
import '../../session/dist/keystone.esm.js';
import '@graphql-tools/merge';
import 'cookie';
import '@hapi/iron';
import 'uid-safe';
import '../../dist/schema-15c288ef.esm.js';
import '@keystone-next/server-side-graphql-client-legacy';
import 'graphql/execution/values';
import '@keystone-next/keystone-legacy';
import '@keystone-next/adapter-mongoose-legacy';
import '@keystone-next/adapter-knex-legacy';
import 'cors';
import 'graphql-upload';
import 'apollo-server-micro';
import 'apollo-server-express';
import '@keystone-next/keystone-legacy/lib/Keystone/format-error';
import '@keystone-next/fields';

const EXTENSIONS = ['.js', '.jsx', '.ts', '.tsx'];
const babelPlugins = [require.resolve('@babel/plugin-transform-modules-commonjs')];

const hook = () => {
  let compiling = false;
  let sourceMaps = {};
  let needsToInstallSourceMapSupport = true;

  function compileHook(code, filename) {
    if (compiling) return code; // we do this lazily because jest has its own require implementation
    // which means preconstruct's require hook won't be run
    // so we don't want to install source map support because that will mess up
    // jest's source map support

    if (needsToInstallSourceMapSupport) {
      sourceMapSupport.install({
        environment: 'node',

        retrieveSourceMap(source) {
          let map = sourceMaps[source];

          if (map !== undefined) {
            return {
              url: source,
              map
            };
          } else {
            return null;
          }
        }

      });
      needsToInstallSourceMapSupport = false;
    }

    try {
      compiling = true;
      const partialConfig = babel.loadPartialConfig({
        plugins: babelPlugins,
        filename,
        sourceMaps: 'both',
        rootMode: 'upward-optional'
      });
      let options = partialConfig.options;

      if (!partialConfig.hasFilesystemConfig()) {
        options = _objectSpread(_objectSpread({}, options), {}, {
          // note that we're explicitly removing the plugin(@babel/plugin-transform-modules-commonjs)
          // we added above because for some reason, it interacts poorly with next/babel
          // and results in stray ESM imports of React when they should be CJS
          // note that we're never going to be removing a consumer's Babel config since
          // that would make hasFilesystemConfig() return true
          plugins: [],
          presets: [require.resolve('next/babel')]
        });
      }

      const output = babel.transformSync(code, options);
      sourceMaps[filename] = output.map;
      return output.code;
    } finally {
      compiling = false;
    }
  }

  return addHook(compileHook, {
    exts: EXTENSIONS
  });
};

const requireSource = filePath => {
  const unregister = hook();

  const result = require(filePath);

  unregister();
  return result;
};

let printEnumTypeDefinition = node => {
  return `export type ${node.name.value} =\n${node.values.map(x => `  | ${JSON.stringify(x.name.value)}`).join('\n')};`;
};

function printInputTypesFromSchema(schema, schemaObj, scalars) {
  let ast = parse(schema);

  let printTypeNodeWithoutNullable = node => {
    if (node.kind === 'ListType') {
      return `ReadonlyArray<${printTypeNode(node.type)}>`;
    }

    let name = node.name.value;

    if (schemaObj.getType(name) instanceof GraphQLScalarType) {
      if (scalars[name] === undefined) {
        return 'any';
      }

      return `Scalars[${JSON.stringify(name)}]`;
    }

    return name;
  };

  let printTypeNode = node => {
    if (node.kind === 'NonNullType') {
      return printTypeNodeWithoutNullable(node.type);
    }

    return `${printTypeNodeWithoutNullable(node)} | null`;
  };

  let printInputObjectTypeDefinition = node => {
    var _node$fields;

    let str = `export type ${node.name.value} = {\n`;
    (_node$fields = node.fields) === null || _node$fields === void 0 ? void 0 : _node$fields.forEach(node => {
      str += `  readonly ${node.name.value}${node.type.kind === 'NonNullType' || node.defaultValue ? '' : '?'}: ${printTypeNode(node.type)};\n`;
    });
    str += '};';
    return str;
  };

  let typeString = 'type Scalars = {\n';

  for (let scalar in scalars) {
    typeString += `  readonly ${scalar}: ${scalars[scalar]};\n`;
  }

  typeString += '};';

  for (const node of ast.definitions) {
    if (node.kind === 'InputObjectTypeDefinition') {
      typeString += '\n\n' + printInputObjectTypeDefinition(node);
    }

    if (node.kind === 'EnumTypeDefinition') {
      typeString += '\n\n' + printEnumTypeDefinition(node);
    }
  }

  return {
    printedTypes: typeString + '\n',
    ast,
    printTypeNode
  };
}

function printGeneratedTypes(printedSchema, keystone, graphQLSchema) {
  let scalars = {
    ID: 'string',
    Boolean: 'boolean',
    String: 'string',
    Int: 'number',
    Float: 'number',
    JSON: 'import("@keystone-next/types").JSONValue'
  };
  let {
    printedTypes,
    ast,
    printTypeNode
  } = printInputTypesFromSchema(printedSchema, graphQLSchema, scalars);
  printedTypes += '\n';
  let allListsStr = '\nexport type KeystoneListsTypeInfo = {';
  let queryTypeName = graphQLSchema.getQueryType().name;
  let queryNode = ast.definitions.find(node => {
    return node.kind === 'ObjectTypeDefinition' && node.name.value === queryTypeName;
  });

  if (!queryNode) {
    throw new Error('Query type on GraphQL schema not found when generating types');
  }

  let queryNodeFieldsByName = {};

  for (const field of queryNode.fields) {
    queryNodeFieldsByName[field.name.value] = field;
  }

  let printArgs = args => {
    let types = '{\n';

    for (const arg of args) {
      if (arg.name.value === 'search' || arg.name.value === 'orderBy') continue;
      types += `  readonly ${arg.name.value}${arg.type.kind === 'NonNullType' || arg.defaultValue ? '' : '?'}: ${printTypeNode(arg.type)};\n`;
    }

    return types + '}';
  };

  for (const listKey in keystone.lists) {
    const list = keystone.lists[listKey];
    let backingTypes = '{\n';

    for (const field of list.fields) {
      for (const [key, {
        optional,
        type
      }] of Object.entries(field.getBackingTypes())) {
        backingTypes += `readonly ${JSON.stringify(key)}${optional ? '?' : ''}: ${type};\n`;
      }
    }

    backingTypes += '}';
    const {
      gqlNames
    } = list;
    let listTypeInfoName = `${listKey}ListTypeInfo`;
    const listQuery = queryNodeFieldsByName[gqlNames.listQueryName];
    printedTypes += `
export type ${listTypeInfoName} = {
  key: ${JSON.stringify(listKey)};
  fields: ${Object.keys(list.fieldsByPath).map(x => JSON.stringify(x)).join('|')}
  backing: ${backingTypes};
  inputs: {
    where: ${gqlNames.whereInputName};
    create: ${gqlNames.createInputName};
    update: ${gqlNames.updateInputName};
  };
  args: {
    listQuery: ${listQuery ? printArgs(listQuery.arguments) : 'import("@keystone-next/types").BaseGeneratedListTypes["args"]["listQuery"]'}
  };
};

export type ${listKey}ListFn = (
  listConfig: import('@keystone-next/keystone/schema').ListConfig<${listTypeInfoName}, ${listTypeInfoName}['fields']>
) => import('@keystone-next/keystone/schema').ListConfig<${listTypeInfoName}, ${listTypeInfoName}['fields']>;
`;
    allListsStr += `\n  readonly ${JSON.stringify(listKey)}: ${listTypeInfoName};`;
  }

  return prettier.format(printedTypes + allListsStr + '\n};\n', {
    parser: 'babel-ts',
    trailingComma: 'es5',
    singleQuote: true
  });
}

async function saveSchemaAndTypes(graphQLSchema, keystone, dotKeystonePath) {
  const printedSchema = printSchema(graphQLSchema);
  await outputFile(path.join(dotKeystonePath, 'schema.graphql'), printedSchema);
  await outputFile(path.join(dotKeystonePath, 'schema-types.ts'), printGeneratedTypes(printedSchema, keystone, graphQLSchema));
}

const CONFIG_PATH = path.join(process.cwd(), 'keystone');

// TODO: Don't generate or start an Admin UI if it isn't configured!!
const devLoadingHTMLFilepath = path.join(path.dirname(require.resolve('@keystone-next/keystone/package.json')), 'src', 'static', 'dev-loading.html');
const dev = async ({
  dotKeystonePath,
  projectAdminPath
}) => {
  var _config$server;

  console.log('âœ¨ Starting Keystone');
  const server = express();
  let expressServer = null;
  const config = initConfig(requireSource(CONFIG_PATH).default);

  const initKeystone = async () => {
    var _config$ui;

    const {
      keystone,
      graphQLSchema,
      createContext
    } = createSystem(config, dotKeystonePath, 'dev');
    console.log('âœ¨ Generating graphQL schema');
    await saveSchemaAndTypes(graphQLSchema, keystone, dotKeystonePath);
    console.log('âœ¨ Connecting to the database');
    await keystone.connect({
      context: createContext().sudo()
    });

    if ((_config$ui = config.ui) !== null && _config$ui !== void 0 && _config$ui.isDisabled) {
      console.log('âœ¨ Skipping Admin UI code generation');
    } else {
      console.log('âœ¨ Generating Admin UI code');
      await generateAdminUI(config, graphQLSchema, keystone, projectAdminPath);
    }

    console.log('âœ¨ Creating server');
    expressServer = await createExpressServer(config, graphQLSchema, createContext, true, projectAdminPath);
    console.log(`ðŸ‘‹ Admin UI and graphQL API ready`);
  };

  server.use('/__keystone_dev_status', (req, res) => {
    res.json({
      ready: expressServer ? true : false
    });
  });
  server.use((req, res, next) => {
    if (expressServer) return expressServer(req, res, next);
    res.sendFile(devLoadingHTMLFilepath);
  });
  const port = ((_config$server = config.server) === null || _config$server === void 0 ? void 0 : _config$server.port) || process.env.PORT || 3000;
  server.listen(port, err => {
    if (err) throw err;
    console.log(`â­ï¸ Dev Server Ready on http://localhost:${port}`); // Don't start initialising Keystone until the dev server is ready,
    // otherwise it slows down the first response significantly

    initKeystone().catch(err => {
      console.error(`ðŸš¨ There was an error initialising Keystone`);
      console.error(err);
      process.exit(1);
    });
  });
};

const start = async ({
  dotKeystonePath,
  projectAdminPath
}) => {
  var _config$ui, _config$server;

  console.log('âœ¨ Starting Keystone'); // This is the compiled version of the configuration which was generated during the build step.
  // See reexportKeystoneConfig().

  const apiFile = path.join(projectAdminPath, '.next/server/pages/api/__keystone_api_build.js');

  if (!fs.existsSync(apiFile)) {
    throw new Error('keystone-next build must be run before running keystone-next start');
  }

  const config = initConfig(require(apiFile).config);
  const {
    keystone,
    graphQLSchema,
    createContext
  } = createSystem(config, dotKeystonePath, 'none-skip-client-generation');
  console.log('âœ¨ Connecting to the database');
  await keystone.connect({
    context: createContext().sudo()
  });
  console.log('âœ¨ Creating server');
  const server = await createExpressServer(config, graphQLSchema, createContext, false, projectAdminPath);

  if ((_config$ui = config.ui) !== null && _config$ui !== void 0 && _config$ui.isDisabled) {
    console.log(`ðŸ‘‹ GraphQL API ready`);
  } else {
    console.log(`ðŸ‘‹ Admin UI and GraphQL API ready`);
  }

  const port = ((_config$server = config.server) === null || _config$server === void 0 ? void 0 : _config$server.port) || process.env.PORT || 3000;
  server.listen(port, err => {
    if (err) throw err;
    console.log(`â­ï¸ Server Ready on http://localhost:${port}`);
  });
};

// FIXME: Duplicated from admin-ui package. Need to decide on a common home.
async function writeAdminFile(file, projectAdminPath) {
  const outputFilename = path.join(projectAdminPath, file.outputPath);

  if (file.mode === 'copy') {
    if (!path.isAbsolute(file.inputPath)) {
      throw new Error(`An inputPath of "${file.inputPath}" was provided to copy but inputPaths must be absolute`);
    }

    await fs__default.ensureDir(path.dirname(outputFilename)); // TODO: should we use copyFile or copy?

    await fs__default.copyFile(file.inputPath, outputFilename);
  }

  if (file.mode === 'write') {
    await fs__default.outputFile(outputFilename, formatSource(file.src));
  }
} // FIXME: Duplicated from admin-ui package. Need to decide on a common home.


function serializePathForImport(path) {
  // JSON.stringify is important here because it will escape windows style paths(and any thing else that might potentionally be in there)
  return JSON.stringify(path // Next is unhappy about imports that include .ts/tsx in them because TypeScript is unhappy with them becasue when doing a TypeScript compilation with tsc, the imports won't be written so they would be wrong there
  .replace(/\.tsx?$/, ''));
} // FIXME: Duplicated from admin-ui package. Need to decide on a common home.

const formatSource = (src, parser = 'babel') => prettier.format(src, {
  parser,
  trailingComma: 'es5',
  singleQuote: true
});

const reexportKeystoneConfig = async (projectAdminPath, isDisabled) => {
  if (isDisabled) {
    // Nuke any existing files in our target directory
    await fs__default.remove(projectAdminPath);
  } // We re-export the Keystone config file into the Admin UI project folder
  // so that when we run the build step, we will end up with a compiled version
  // of the configuration file in the .next/ directory. Even if we're not building
  // an Admin UI, we still need to run the `build()` function so that this config
  // file is correctly compiled.


  const pkgDir = path.dirname(require.resolve('@keystone-next/admin-ui/package.json'));
  const files = [{
    mode: 'write',
    src: `export { default as config } from ${serializePathForImport(path.relative(path.join(projectAdminPath, 'pages', 'api'), CONFIG_PATH))}
            export default function (req, res) { return res.status(500) }`,
    outputPath: path.join('pages', 'api', '__keystone_api_build.js')
  }];

  if (isDisabled) {
    // These are the basic files required to have a valid Next.js project. If the
    // Admin UI is disabled then we need to do this ourselves here.
    files.push({
      mode: 'copy',
      inputPath: path.join(pkgDir, 'static', 'next.config.js'),
      outputPath: 'next.config.js'
    }, {
      mode: 'copy',
      inputPath: path.join(pkgDir, 'static', 'tsconfig.json'),
      outputPath: 'tsconfig.json'
    });
  }

  await Promise.all(files.map(file => writeAdminFile(file, projectAdminPath)));
};

async function build({
  dotKeystonePath,
  projectAdminPath
}) {
  var _config$ui, _config$ui2;

  console.log('âœ¨ Building Keystone');
  const config = initConfig(requireSource(CONFIG_PATH).default);
  const {
    keystone,
    graphQLSchema
  } = createSystem(config, dotKeystonePath, 'none');
  console.log('âœ¨ Generating graphQL schema');
  await saveSchemaAndTypes(graphQLSchema, keystone, dotKeystonePath);

  if ((_config$ui = config.ui) !== null && _config$ui !== void 0 && _config$ui.isDisabled) {
    console.log('âœ¨ Skipping Admin UI code generation');
  } else {
    console.log('âœ¨ Generating Admin UI code');
    await generateAdminUI(config, graphQLSchema, keystone, projectAdminPath);
  }

  console.log('âœ¨ Generating Keystone config code');
  await reexportKeystoneConfig(projectAdminPath, (_config$ui2 = config.ui) === null || _config$ui2 === void 0 ? void 0 : _config$ui2.isDisabled);
  console.log('âœ¨ Generating database client'); // FIXME: This should never generate a migratration... right?
  // FIXME: This needs to generate clients for the correct build target using binaryTarget
  // https://www.prisma.io/docs/reference/api-reference/prisma-schema-reference#binarytargets-options

  if (keystone.adapter.name === 'prisma') {
    await keystone.adapter._generateClient(keystone._consolidateRelationships());
  }

  console.log('âœ¨ Building Admin UI');
  await buildAdminUI(projectAdminPath);
}

const deploy = async ({
  dotKeystonePath
}) => {
  const config = initConfig(requireSource(CONFIG_PATH).default);

  if (config.db.adapter !== 'prisma_postgresql' && config.db.adapter !== 'prisma_sqlite') {
    console.log('keystone-next deploy only supports Prisma');
    process.exit(1);
  }

  if (!config.db.useMigrations) {
    console.log('db.useMigrations must be set to true in your config to use keystone-next deploy');
    process.exit(1);
  }

  const keystone = createKeystone(config, dotKeystonePath, 'none');
  console.log('âœ¨ Deploying migrations');
  await keystone.adapter.deploy(keystone._consolidateRelationships());
  console.log('âœ… Deployed migrations');
};

const generate = async ({
  dotKeystonePath
}, args) => {
  const config = initConfig(requireSource(CONFIG_PATH).default);

  if (config.db.adapter !== 'prisma_postgresql' && config.db.adapter !== 'prisma_sqlite') {
    console.log('keystone-next generate only supports Prisma');
    process.exit(1);
  }

  if (!config.db.useMigrations) {
    console.log('db.useMigrations must be set to true in your config to use keystone-next generate');
    process.exit(1);
  }

  const {
    keystone
  } = createSystem(config, dotKeystonePath, 'none');
  await keystone.adapter._generateClient(keystone._consolidateRelationships());
  await createMigration(config.db.url, keystone.adapter.prismaSchema, path.resolve(keystone.adapter.schemaPath), args);
};

const reset = async ({
  dotKeystonePath
}) => {
  const config = initConfig(requireSource(CONFIG_PATH).default);
  const keystone = createKeystone(config, dotKeystonePath, 'none');
  console.log('âœ¨ Resetting database');
  await keystone.adapter._prepareSchema(keystone._consolidateRelationships());
  await keystone.adapter.dropDatabase();
  console.log('âœ… Database reset');
};

const commands = {
  dev,
  start,
  build,
  deploy,
  generate,
  reset
};

function cli() {
  const {
    input,
    help,
    flags
  } = meow(`
    Usage
      $ keystone-next [command]
    Commands
      Run
        dev           (default) start the project in development mode
        start         start the project in production mode
      Build
        build         build the project (must be done before using start)
      Migrate (Prisma only)
        reset         reset the database (this will drop all data!)
        generate      generate a migration
        deploy        deploy all migrations
    `, {
    flags: {
      allowEmpty: {
        default: false,
        type: 'boolean'
      },
      acceptDataLoss: {
        default: false,
        type: 'boolean'
      },
      name: {
        type: 'string'
      }
    }
  });
  const command = input[0] || 'dev';

  if (!isCommand(command)) {
    console.log(`${command} is not a command that keystone-next accepts`);
    console.log(help);
    process.exit(1);
  } // These paths are non-configurable, as we need to use them
  // to find the config file (for `start`) itself!


  const dotKeystonePath = path.resolve('.keystone');
  const projectAdminPath = path.join(dotKeystonePath, 'admin');
  const staticPaths = {
    dotKeystonePath,
    projectAdminPath
  };

  if (command === 'generate') {
    generate(staticPaths, flags);
  } else {
    commands[command](staticPaths);
  }
}

function isCommand(command) {
  return command in commands;
}

cli();
