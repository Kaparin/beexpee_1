/// <reference types="node" />
import { IncomingMessage } from 'http';
import { GraphQLSchema, ExecutionResult, DocumentNode } from 'graphql';
import { BaseKeystone } from './base';
import type { BaseGeneratedListTypes } from './utils';
export declare type KeystoneContext = {
    req?: IncomingMessage;
    lists: KeystoneListsAPI<any>;
    graphql: KeystoneGraphQLAPI<any>;
    sudo: () => KeystoneContext;
    exitSudo: () => KeystoneContext;
    withSession: (session: any) => KeystoneContext;
    totalResults: number;
    maxTotalResults: number;
    schemaName: 'public' | 'internal';
    /** @deprecated */
    gqlNames: (listKey: string) => Record<string, string>;
    /** @deprecated */
    executeGraphQL: any;
    /** @deprecated */
    keystone: BaseKeystone;
} & AccessControlContext & Partial<SessionContext<any>> & DatabaseAPIs;
export declare type KeystoneListsAPI<KeystoneListsTypeInfo extends Record<string, BaseGeneratedListTypes>> = {
    [Key in keyof KeystoneListsTypeInfo]: {
        findMany(args: KeystoneListsTypeInfo[Key]['args']['listQuery'] & ResolveFields): Promise<readonly KeystoneListsTypeInfo[Key]['backing'][]>;
        findOne(args: {
            readonly where: {
                readonly id: string;
            };
        } & ResolveFields): Promise<KeystoneListsTypeInfo[Key]['backing'] | null>;
        count(args: KeystoneListsTypeInfo[Key]['args']['listQuery']): Promise<number>;
        updateOne(args: {
            readonly id: string;
            readonly data: KeystoneListsTypeInfo[Key]['inputs']['update'];
        } & ResolveFields): Promise<KeystoneListsTypeInfo[Key]['backing'] | null>;
        updateMany(args: {
            readonly data: readonly {
                readonly id: string;
                readonly data: KeystoneListsTypeInfo[Key]['inputs']['update'];
            }[];
        } & ResolveFields): Promise<(KeystoneListsTypeInfo[Key]['backing'] | null)[] | null>;
        createOne(args: {
            readonly data: KeystoneListsTypeInfo[Key]['inputs']['create'];
        } & ResolveFields): Promise<KeystoneListsTypeInfo[Key]['backing'] | null>;
        createMany(args: {
            readonly data: readonly {
                readonly data: KeystoneListsTypeInfo[Key]['inputs']['update'];
            }[];
        } & ResolveFields): Promise<(KeystoneListsTypeInfo[Key]['backing'] | null)[] | null>;
        deleteOne(args: {
            readonly id: string;
        } & ResolveFields): Promise<KeystoneListsTypeInfo[Key]['backing'] | null>;
        deleteMany(args: {
            readonly ids: readonly string[];
        } & ResolveFields): Promise<(KeystoneListsTypeInfo[Key]['backing'] | null)[] | null>;
    };
};
declare type ResolveFields = {
    readonly resolveFields?: false | string;
};
export declare type KeystoneGraphQLAPI<KeystoneListsTypeInfo extends Record<string, BaseGeneratedListTypes>> = {
    schema: GraphQLSchema;
    run: (args: GraphQLExecutionArguments) => Promise<Record<string, any>>;
    raw: (args: GraphQLExecutionArguments) => Promise<ExecutionResult>;
};
declare type GraphQLExecutionArguments = {
    query: string | DocumentNode;
    variables?: Record<string, any>;
};
export declare type AccessControlContext = {
    getListAccessControlForUser: any;
    getFieldAccessControlForUser: any;
};
export declare type SessionContext<T> = {
    session?: {
        itemId: string;
        listKey: string;
        data?: Record<string, any>;
    } | any;
    startSession(data: T): Promise<string>;
    endSession(): Promise<void>;
};
export declare type DatabaseAPIs = {
    knex?: any;
    mongoose?: any;
    prisma?: any;
};
export {};
