'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var utilsLegacy = require('@keystone-next/utils-legacy');

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    });
    keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread2(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};

    if (i % 2) {
      ownKeys(Object(source), true).forEach(function (key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }

  return target;
}

const checkSchemaNames = ({
  schemaNames,
  accessTypes,
  access
}) => {
  if (schemaNames.includes('internal')) {
    throw new Error(`"internal" is a reserved word and cannot be used as a schema name.`);
  } // Check that none of the schemaNames match the accessTypes


  const matchingNames = utilsLegacy.intersection(schemaNames, accessTypes);

  if (matchingNames.length > 0) {
    throw new Error(`${JSON.stringify(matchingNames)} are reserved words and cannot be used as schema names.`);
  }

  if (typeof access === 'object') {
    const accessKeys = Object.keys(access);
    const providedNameCount = utilsLegacy.intersection(accessKeys, schemaNames).length;

    if (providedNameCount > 0 && providedNameCount < accessKeys.length) {
      // If some are in, and some are out, throw an error!
      const ks = accessKeys.filter(k => !schemaNames.includes(k));
      throw new Error(`Invalid schema names: ${JSON.stringify(ks)}`);
    }
  }

  const keyedBySchemaName = typeof access === 'object' && utilsLegacy.intersection(Object.keys(access), schemaNames).length === Object.keys(access).length;
  return keyedBySchemaName;
};

function parseListAccess({
  listKey,
  defaultAccess,
  access = defaultAccess,
  schemaNames
}) {
  const accessTypes = ['create', 'read', 'update', 'delete', 'auth'];
  const keyedBySchemaName = checkSchemaNames({
    schemaNames,
    accessTypes,
    access
  });
  const fullAccess = keyedBySchemaName ? _objectSpread2(_objectSpread2({}, utilsLegacy.defaultObj(schemaNames, defaultAccess)), access) // Access keyed by schemaName
  : utilsLegacy.defaultObj(schemaNames, access); // Access not keyed by schemaName

  const parseAndValidate = (access = {}) => {
    if (typeof access === 'boolean' || typeof access === 'function') {
      return utilsLegacy.defaultObj(accessTypes, access);
    } else if (typeof access === 'object') {
      const _access = access;

      if (Object.keys(utilsLegacy.pick(_access, accessTypes)).length === 0) {
        // An object was supplied, but it has the wrong keys (it's probably a
        // declarative access control config being used as a shorthand, which
        // isn't possible [due to `create` not supporting declarative config])
        const at = JSON.stringify(accessTypes);
        const aks = JSON.stringify(Object.keys(access));
        throw new Error(`Must specify one of ${at} access configs, but got ${aks}. (Did you mean to specify a declarative access control config? This can be done on a granular basis only)`);
      }

      return _objectSpread2(_objectSpread2({}, utilsLegacy.defaultObj(accessTypes, defaultAccess)), utilsLegacy.pick(_access, accessTypes));
    } else {
      throw new Error(`Shorthand access must be specified as either a boolean or a function, received ${typeof access}.`);
    }
  };

  const fullParsedAccess = _objectSpread2(_objectSpread2({}, schemaNames.reduce((acc, schemaName) => _objectSpread2(_objectSpread2({}, acc), {}, {
    [schemaName]: parseAndValidate(fullAccess[schemaName])
  }), {})), {}, {
    internal: utilsLegacy.defaultObj(accessTypes, true)
  });

  Object.values(fullParsedAccess).forEach(parsedAccess => {
    const errors = Object.entries(parsedAccess).map(([accessType, access]) => {
      if (accessType === 'create') {
        if (!['boolean', 'function'].includes(typeof access)) {
          return `Expected a Boolean, or Function for ${listKey}.access.${accessType}, but got ${typeof access}. (NOTE: 'create' cannot have a Declarative access control config)`;
        }
      } else {
        if (!['object', 'boolean', 'function'].includes(typeof access)) {
          return `Expected a Boolean, Object, or Function for ${listKey}.access.${accessType}, but got ${typeof access}`;
        }
      }
    }).filter(error => error);

    if (errors.length) {
      throw new Error(errors.join('\n'));
    }
  });
  return fullParsedAccess;
}
function parseFieldAccess({
  listKey,
  fieldKey,
  defaultAccess,
  access = defaultAccess,
  schemaNames
}) {
  const accessTypes = ['create', 'read', 'update'];
  const keyedBySchemaName = checkSchemaNames({
    schemaNames,
    accessTypes,
    access
  });
  const fullAccess = keyedBySchemaName ? _objectSpread2(_objectSpread2({}, utilsLegacy.defaultObj(schemaNames, defaultAccess)), access) // Access keyed by schemaName
  : utilsLegacy.defaultObj(schemaNames, access); // Access not keyed by schemaName

  const parseAndValidate = (access = {}) => {
    if (typeof access === 'boolean' || typeof access === 'function') {
      return utilsLegacy.defaultObj(accessTypes, access);
    } else if (typeof access === 'object') {
      const _access = access;

      if (Object.keys(utilsLegacy.pick(_access, accessTypes)).length === 0) {
        // An object was supplied, but it has the wrong keys (it's probably a
        // declarative access control config being used as a shorthand, which
        // isn't possible [due to `create` not supporting declarative config])
        const at = JSON.stringify(accessTypes);
        const aks = JSON.stringify(Object.keys(access));
        throw new Error(`Must specify one of ${at} access configs, but got ${aks}. (Did you mean to specify a declarative access control config? This can be done on lists only)`);
      }

      return _objectSpread2(_objectSpread2({}, utilsLegacy.defaultObj(accessTypes, defaultAccess)), utilsLegacy.pick(_access, accessTypes));
    } else {
      throw new Error(`Shorthand access must be specified as either a boolean or a function, received ${typeof access}.`);
    }
  };

  const fullParsedAccess = _objectSpread2(_objectSpread2({}, schemaNames.reduce((acc, schemaName) => _objectSpread2(_objectSpread2({}, acc), {}, {
    [schemaName]: parseAndValidate(fullAccess[schemaName])
  }), {})), {}, {
    internal: utilsLegacy.defaultObj(accessTypes, true)
  });

  Object.values(fullParsedAccess).forEach(parsedAccess => {
    const errors = Object.entries(parsedAccess).map(([accessType, access]) => {
      if (!['boolean', 'function'].includes(typeof access)) {
        return `Expected a Boolean or Function for ${listKey}.fields.${fieldKey}.access.${accessType}, but got ${typeof access}. (NOTE: Fields cannot have declarative access control config)`;
      }
    }).filter(error => error);

    if (errors.length) {
      throw new Error(errors.join('\n'));
    }
  });
  return fullParsedAccess;
}
async function validateListAccessControl({
  access,
  args
}) {
  // Either a boolean or an object describing a where clause
  let result = false;
  const acc = access[args.operation];

  if (typeof acc !== 'function') {
    result = acc;
  } else {
    result = await acc(args);
  }

  if (!['object', 'boolean'].includes(typeof result)) {
    throw new Error(`Must return an Object or Boolean from Imperative or Declarative access control function. Got ${typeof result}`);
  } // Special case for 'create' permission


  if (args.operation === 'create' && typeof result === 'object') {
    throw new Error(`Expected a Boolean for ${args.listKey}.access.create(), but got Object. (NOTE: 'create' cannot have a Declarative access control config)`);
  }

  return result;
}
async function validateFieldAccessControl({
  access,
  args
}) {
  let result = false;
  const acc = access[args.operation];

  if (typeof acc !== 'function') {
    result = acc;
  } else {
    result = await acc(args);
  }

  if (typeof result !== 'boolean') {
    throw new Error(`Must return a Boolean from ${args.listKey}.fields.${args.fieldKey}.access.${args.operation}(). Got ${typeof result}`);
  }

  return result;
}
async function validateAuthAccessControl({
  access,
  args
}) {
  // Either a boolean or an object describing a where clause
  let result = false;
  const acc = access[args.operation];

  if (typeof acc !== 'function') {
    result = acc;
  } else {
    result = await acc(args);
  }

  if (!['object', 'boolean'].includes(typeof result)) {
    throw new Error(`Must return an Object or Boolean from Imperative or Declarative access control function. Got ${typeof result}`);
  }

  return result;
}

exports.parseFieldAccess = parseFieldAccess;
exports.parseListAccess = parseListAccess;
exports.validateAuthAccessControl = validateAuthAccessControl;
exports.validateFieldAccessControl = validateFieldAccessControl;
exports.validateListAccessControl = validateListAccessControl;
