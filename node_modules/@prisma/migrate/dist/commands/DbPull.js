"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.DbPull = void 0;
const sdk_1 = require("@prisma/sdk");
const chalk_1 = __importDefault(require("chalk"));
const path_1 = __importDefault(require("path"));
const sdk_2 = require("@prisma/sdk");
const formatms_1 = require("../utils/formatms");
const fs_1 = __importDefault(require("fs"));
const convertCredentials_1 = require("@prisma/sdk/dist/convertCredentials");
const printDatasources_1 = require("../utils/printDatasources");
const removeDatasource_1 = require("../utils/removeDatasource");
class DbPull {
    static new() {
        return new DbPull();
    }
    printUrlAsDatasource(url) {
        const provider = convertCredentials_1.databaseTypeToConnectorType(sdk_2.uriToCredentials(url).type);
        return printDatasources_1.printDatasources([
            {
                config: {},
                provider: [provider],
                name: 'db',
                url,
            },
        ]);
    }
    async parse(argv) {
        const args = sdk_1.arg(argv, {
            '--help': Boolean,
            '-h': '--help',
            '--url': String,
            '--print': Boolean,
            '--schema': String,
            '--force': Boolean,
            // deprecated
            '--experimental-reintrospection': Boolean,
            '--clean': Boolean,
        });
        const log = (...messages) => {
            if (!args['--print']) {
                console.log(...messages);
            }
        };
        if (args instanceof Error) {
            return this.help(args.message);
        }
        if (args['--help']) {
            return this.help();
        }
        if (args['--clean'] || args['--experimental-reintrospection']) {
            const renamedMessages = [];
            if (args['--experimental-reintrospection']) {
                renamedMessages.push(`The ${chalk_1.default.redBright('--experimental-reintrospection')} flag has been removed and is now the default behavior of ${chalk_1.default.greenBright('prisma db pull')}.`);
            }
            if (args['--clean']) {
                renamedMessages.push(`The ${chalk_1.default.redBright('--clean')} flag has been renamed to ${chalk_1.default.greenBright('--force')}.`);
            }
            console.error(`\n${renamedMessages.join('\n')}\n`);
            process.exit(1);
        }
        const url = args['--url'];
        let schemaPath = await sdk_1.getSchemaPath(args['--schema']);
        if (schemaPath) {
            console.log(chalk_1.default.dim(`Prisma schema loaded from ${path_1.default.relative(process.cwd(), schemaPath)}`));
        }
        if (!url && !schemaPath) {
            throw new Error(`Could not find a ${chalk_1.default.bold('schema.prisma')} file that is required for this command.\nYou can either provide it with ${chalk_1.default.greenBright('--schema')}, set it as \`prisma.schema\` in your package.json or put it into the default location ${chalk_1.default.greenBright('./prisma/schema.prisma')} https://pris.ly/d/prisma-schema-location`);
        }
        let schema = null;
        if (url && schemaPath) {
            schema = this.printUrlAsDatasource(url);
            const rawSchema = fs_1.default.readFileSync(schemaPath, 'utf-8');
            schema += removeDatasource_1.removeDatasource(rawSchema);
        }
        else if (url) {
            schema = this.printUrlAsDatasource(url);
        }
        else if (schemaPath) {
            schema = fs_1.default.readFileSync(schemaPath, 'utf-8');
        }
        else {
            throw new Error('Could not find a `schema.prisma` file');
        }
        const engine = new sdk_2.IntrospectionEngine({
            cwd: schemaPath ? path_1.default.dirname(schemaPath) : undefined,
        });
        const basedOn = !args['--url'] && schemaPath
            ? ` based on datasource defined in ${chalk_1.default.underline(path_1.default.relative(process.cwd(), schemaPath))}`
            : '';
        log(`\nIntrospecting${basedOn} …`);
        const before = Date.now();
        let introspectionSchema = '';
        let introspectionWarnings;
        let introspectionSchemaVersion;
        try {
            const introspectionResult = await engine.introspect(schema, args['--force']);
            introspectionSchema = introspectionResult.datamodel;
            introspectionWarnings = introspectionResult.warnings;
            introspectionSchemaVersion = introspectionResult.version;
        }
        catch (e) {
            if (e.code === 'P4001') {
                if (introspectionSchema.trim() === '') {
                    throw new Error(`\n${chalk_1.default.red.bold('P4001 ')}${chalk_1.default.red('The introspected database was empty:')} ${url ? chalk_1.default.underline(url) : ''}

${chalk_1.default.bold('prisma db pull')} could not create any models in your ${chalk_1.default.bold('schema.prisma')} file and you will not be able to generate Prisma Client with the ${chalk_1.default.bold(sdk_1.getCommandWithExecutor('prisma generate'))} command.

${chalk_1.default.bold('To fix this, you have two options:')}

- manually create a table in your database (using SQL).
- make sure the database connection URL inside the ${chalk_1.default.bold('datasource')} block in ${chalk_1.default.bold('schema.prisma')} points to a database that is not empty (it must contain at least one table).

Then you can run ${chalk_1.default.green(sdk_1.getCommandWithExecutor('prisma db pull'))} again. 
`);
                }
            }
            else if (e.code === 'P1012') {
                // Schema Parsing Error
                console.log(); // empty line
                throw new Error(`${chalk_1.default.red(`${e.code} Introspection failed as your current Prisma schema file is invalid`)}\n
Please fix your current schema manually, use ${chalk_1.default.green(sdk_1.getCommandWithExecutor('prisma validate'))} to confirm it is valid and then run this command again.
Or run this command with the ${chalk_1.default.green('--force')} flag to ignore your current schema and overwrite it. All local modifications will be lost.\n`);
            }
            throw e;
        }
        function getWarningMessage(warnings) {
            if (warnings.length > 0) {
                let message = `\n*** WARNING ***\n`;
                for (const warning of warnings) {
                    message += `\n${warning.message}\n`;
                    if (warning.code === 0) {
                        // affected === null
                    }
                    else if (warning.code === 1) {
                        message += warning.affected
                            .map((it) => `- "${it.model}"`)
                            .join('\n');
                    }
                    else if (warning.code === 2) {
                        const modelsGrouped = warning.affected.reduce((acc, it) => {
                            if (!acc[it.model]) {
                                acc[it.model] = [];
                            }
                            acc[it.model].push(it.field);
                            return acc;
                        }, {});
                        message += Object.entries(modelsGrouped)
                            .map(([model, fields]) => `- Model: "${model}"\n  Field(s): "${fields.join('", "')}"`)
                            .join('\n');
                    }
                    else if (warning.code === 3) {
                        message += warning.affected
                            .map((it) => `- Model "${it.model}", field: "${it.field}", original data type: "${it.tpe}"`)
                            .join('\n');
                    }
                    else if (warning.code === 4) {
                        message += warning.affected
                            .map((it) => `- Enum "${it.enm}", value: "${it.value}"`)
                            .join('\n');
                    }
                    else if (warning.code === 5 ||
                        warning.code === 6 ||
                        warning.code === 8 ||
                        warning.code === 11 ||
                        warning.code === 12 ||
                        warning.code === 13) {
                        message += warning.affected
                            .map((it) => `- Model "${it.model}", field: "${it.field}"`)
                            .join('\n');
                    }
                    else if (warning.code === 7) {
                        message += warning.affected
                            .map((it) => `- Model "${it.model}"`)
                            .join('\n');
                    }
                    else if (warning.code === 9 || warning.code === 10) {
                        message += warning.affected
                            .map((it) => `- Enum "${it.enm}"`)
                            .join('\n');
                    }
                    else if (warning.affected) {
                        // Output unhandled warning
                        message += `Code ${warning.code}\n${JSON.stringify(warning.affected, null, 2)}`;
                    }
                    message += `\n`;
                }
                return message;
            }
        }
        const introspectionWarningsMessage = getWarningMessage(introspectionWarnings) || '';
        const prisma1UpgradeMessage = introspectionSchemaVersion.includes('Prisma1')
            ? `\n${chalk_1.default.bold('Upgrading from Prisma 1 to Prisma 2')}
      \nThe database you introspected seems to belong to a Prisma 1 project.

Please run the following command to upgrade to Prisma 2.0:
${chalk_1.default.green('npx prisma-upgrade [path-to-prisma-yml] [path-to-schema-prisma]')}

Note: \`prisma.yml\` and \`schema.prisma\` paths are optional.
 
Learn more about the upgrade process in the docs:\n${sdk_1.link('https://pris.ly/d/upgrading-to-prisma2')}`
            : '';
        const prisma1UpgradeMessageBox = prisma1UpgradeMessage
            ? '\n\n' +
                sdk_1.drawBox({
                    height: 13,
                    width: 74,
                    str: prisma1UpgradeMessage,
                    horizontalPadding: 2,
                })
            : '';
        if (args['--print']) {
            console.log(introspectionSchema);
            introspectionSchemaVersion &&
                console.log(`\n// introspectionSchemaVersion: ${introspectionSchemaVersion}`, prisma1UpgradeMessage.replace(/(\n)/gm, '\n// '));
            if (introspectionWarningsMessage.trim().length > 0) {
                console.error(introspectionWarningsMessage);
            }
        }
        else {
            schemaPath = schemaPath || 'schema.prisma';
            fs_1.default.writeFileSync(schemaPath, introspectionSchema);
            const modelsCount = (introspectionSchema.match(/^model\s+/gm) || [])
                .length;
            log(`\n✔ Introspected ${modelsCount} ${modelsCount > 1 ? 'models and wrote them' : 'model and wrote it'} into ${chalk_1.default.underline(path_1.default.relative(process.cwd(), schemaPath))} in ${chalk_1.default.bold(formatms_1.formatms(Date.now() - before))}${prisma1UpgradeMessageBox}
      ${chalk_1.default.keyword('orange')(introspectionWarningsMessage)}
${prisma1UpgradeMessage
                ? `Once you upgraded your database schema to Prisma 2.0, run ${chalk_1.default.green(sdk_1.getCommandWithExecutor('prisma generate'))} to generate Prisma Client.`
                : `Run ${chalk_1.default.green(sdk_1.getCommandWithExecutor('prisma generate'))} to generate Prisma Client.`}`);
        }
        engine.stop();
        return '';
    }
    help(error) {
        if (error) {
            return new sdk_1.HelpError(`\n${chalk_1.default.bold.red(`!`)} ${error}\n${DbPull.help}`);
        }
        return DbPull.help;
    }
}
exports.DbPull = DbPull;
DbPull.help = sdk_1.format(`
Pull the state from the database to the Prisma schema using introspection

${chalk_1.default.bold('Usage')}

  ${chalk_1.default.dim('$')} prisma db pull [options]

${chalk_1.default.bold('Options')}

  -h, --help   Display this help message
    --schema   Custom path to your Prisma schema
     --force   Ignore current Prisma schema file
     --print   Print the introspected Prisma schema to stdout

${chalk_1.default.bold('Examples')}

With an existing Prisma schema
  ${chalk_1.default.dim('$')} prisma db pull

Or specify a Prisma schema path
  ${chalk_1.default.dim('$')} prisma db pull --schema=./schema.prisma

Instead of saving the result to the filesystem, you can also print it to stdout
  ${chalk_1.default.dim('$')} prisma db pull --print

`);
//# sourceMappingURL=DbPull.js.map