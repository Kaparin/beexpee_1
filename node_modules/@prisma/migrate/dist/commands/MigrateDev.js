"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.MigrateDev = void 0;
const sdk_1 = require("@prisma/sdk");
const debug_1 = __importDefault(require("@prisma/debug"));
const chalk_1 = __importDefault(require("chalk"));
const prompts_1 = __importDefault(require("prompts"));
const fs_1 = __importDefault(require("fs"));
const path_1 = __importDefault(require("path"));
const Migrate_1 = require("../Migrate");
const ensureDatabaseExists_1 = require("../utils/ensureDatabaseExists");
const flagErrors_1 = require("../utils/flagErrors");
const errors_1 = require("../utils/errors");
const printMigrationId_1 = require("../utils/printMigrationId");
const printFiles_1 = require("../utils/printFiles");
const handleEvaluateDataloss_1 = require("../utils/handleEvaluateDataloss");
const promptForMigrationName_1 = require("../utils/promptForMigrationName");
const detectOldMigrate_1 = require("../utils/detectOldMigrate");
const printDatasource_1 = require("../utils/printDatasource");
const seed_1 = require("../utils/seed");
const debug = debug_1.default('prisma:migrate:dev');
class MigrateDev {
    static new() {
        return new MigrateDev();
    }
    async parse(argv) {
        var _a;
        const args = sdk_1.arg(argv, {
            '--help': Boolean,
            '-h': '--help',
            '--name': String,
            '-n': '--name',
            // '--force': Boolean,
            // '-f': '--force',
            '--create-only': Boolean,
            '--schema': String,
            '--skip-generate': Boolean,
            '--skip-seed': Boolean,
            '--experimental': Boolean,
            '--early-access-feature': Boolean,
            '--telemetry-information': String,
        });
        if (sdk_1.isError(args)) {
            return this.help(args.message);
        }
        if (args['--help']) {
            return this.help();
        }
        if (args['--experimental']) {
            throw new flagErrors_1.ExperimentalFlagWithNewMigrateError();
        }
        if (args['--early-access-feature']) {
            throw new flagErrors_1.EarlyAccessFeatureFlagWithNewMigrateError();
        }
        const schemaPath = await sdk_1.getSchemaPath(args['--schema']);
        if (!schemaPath) {
            throw new errors_1.NoSchemaFoundError();
        }
        console.info(chalk_1.default.dim(`Prisma schema loaded from ${path_1.default.relative(process.cwd(), schemaPath)}`));
        await printDatasource_1.printDatasource(schemaPath);
        console.info(); // empty line
        detectOldMigrate_1.throwUpgradeErrorIfOldMigrate(schemaPath);
        // Validate schema (same as prisma validate)
        const schema = fs_1.default.readFileSync(schemaPath, 'utf-8');
        await sdk_1.getDMMF({
            datamodel: schema,
        });
        await sdk_1.getConfig({
            datamodel: schema,
        });
        // Automatically create the database if it doesn't exist
        const wasDbCreated = await ensureDatabaseExists_1.ensureDatabaseExists('create', true, schemaPath);
        if (wasDbCreated) {
            console.info(wasDbCreated);
        }
        const migrate = new Migrate_1.Migrate(schemaPath);
        const devDiagnostic = await migrate.devDiagnostic();
        debug({ devDiagnostic: JSON.stringify(devDiagnostic, null, 2) });
        const migrationIdsApplied = [];
        if (devDiagnostic.action.tag === 'reset') {
            if (!args['--force']) {
                // We use prompts.inject() for testing in our CI
                if (sdk_1.isCi() && Boolean((_a = prompts_1.default._injected) === null || _a === void 0 ? void 0 : _a.length) === false) {
                    throw new errors_1.MigrateDevEnvNonInteractiveError();
                }
                const dbInfo = await ensureDatabaseExists_1.getDbInfo(schemaPath);
                const confirmedReset = await this.confirmReset(dbInfo, devDiagnostic.action.reason);
                console.info(); // empty line
                if (!confirmedReset) {
                    console.info('Reset cancelled.');
                    process.exit(0);
                    // For snapshot test, because exit() is mocked
                    return ``;
                }
            }
            // Do the reset
            await migrate.reset();
        }
        const { appliedMigrationNames } = await migrate.applyMigrations();
        migrationIdsApplied.push(...appliedMigrationNames);
        // Inform user about applied migrations now
        if (appliedMigrationNames.length > 0) {
            console.info(`The following migration(s) have been applied:\n\n${chalk_1.default(printFiles_1.printFilesFromMigrationIds('migrations', appliedMigrationNames, {
                'migration.sql': '',
            }))}`);
        }
        // If database was reset we want to run the seed if not skipped
        if (devDiagnostic.action.tag === 'reset' &&
            !process.env.MIGRATE_SKIP_SEED &&
            !args['--skip-seed']) {
            // Run seed if 1 or more seed files are present
            // And catch the error to continue execution
            try {
                const detected = seed_1.detectSeedFiles(schemaPath);
                if (detected.numberOfSeedFiles > 0) {
                    console.info(); // empty line
                    await seed_1.tryToRunSeed(schemaPath);
                }
            }
            catch (e) {
                console.error(e);
            }
        }
        const evaluateDataLossResult = await migrate.evaluateDataLoss();
        debug({ evaluateDataLossResult });
        // display unexecutableSteps
        // throws error if not create-only
        handleEvaluateDataloss_1.handleUnexecutableSteps(evaluateDataLossResult.unexecutableSteps, args['--create-only']);
        // log warnings and prompt user to continue if needed
        const userCancelled = await handleEvaluateDataloss_1.handleWarnings(evaluateDataLossResult.warnings, args['--force'], args['--create-only']);
        if (userCancelled) {
            migrate.stop();
            return `Migration cancelled.`;
        }
        let migrationName = undefined;
        if (evaluateDataLossResult.migrationSteps.length > 0 ||
            args['--create-only']) {
            const getMigrationNameResult = await promptForMigrationName_1.getMigrationName(args['--name']);
            if (getMigrationNameResult.userCancelled) {
                migrate.stop();
                return getMigrationNameResult.userCancelled;
            }
            else {
                migrationName = getMigrationNameResult.name;
            }
        }
        const createMigrationResult = await migrate.createMigration({
            migrationsDirectoryPath: migrate.migrationsDirectoryPath,
            migrationName: migrationName || '',
            draft: args['--create-only'] ? true : false,
            prismaSchema: migrate.getDatamodel(),
        });
        debug({ createMigrationResult });
        if (args['--create-only']) {
            migrate.stop();
            // console.info() // empty line
            return `Prisma Migrate created the following migration without applying it ${printMigrationId_1.printMigrationId(createMigrationResult.generatedMigrationName)}\n\nYou can now edit it and apply it by running ${chalk_1.default.greenBright(sdk_1.getCommandWithExecutor('prisma migrate dev'))}.`;
        }
        const { appliedMigrationNames: migrationIds, } = await migrate.applyMigrations();
        migrate.stop();
        // For display only, empty line
        migrationIdsApplied.length > 0 && console.info();
        if (migrationIds.length === 0) {
            if (migrationIdsApplied.length > 0) {
                console.info(`${chalk_1.default.green('Your database is now in sync with your schema.')}`);
            }
            else {
                console.info(`Already in sync, no schema change or pending migration was found.`);
            }
        }
        else {
            console.info(`The following migration(s) have been created and applied from new schema changes:\n\n${chalk_1.default(printFiles_1.printFilesFromMigrationIds('migrations', migrationIds, {
                'migration.sql': '',
            }))}

${chalk_1.default.green('Your database is now in sync with your schema.')}`);
        }
        // Run if not skipped
        if (!process.env.MIGRATE_SKIP_GENERATE && !args['--skip-generate']) {
            await migrate.tryToRunGenerate();
            console.info(); // empty line
        }
        return '';
    }
    async confirmReset({ schemaWord, dbType, dbName, dbLocation }, reason) {
        const mssqlMessage = `${reason}

We need to reset the database.
Do you want to continue? ${chalk_1.default.red('All data will be lost')}.`;
        const message = `${reason}

We need to reset the ${dbType} ${schemaWord} "${dbName}" at "${dbLocation}".
Do you want to continue? ${chalk_1.default.red('All data will be lost')}.`;
        const confirmation = await prompts_1.default({
            type: 'confirm',
            name: 'value',
            message: dbType ? message : mssqlMessage,
        });
        return confirmation.value;
    }
    help(error) {
        if (error) {
            return new sdk_1.HelpError(`\n${chalk_1.default.bold.red(`!`)} ${error}\n${MigrateDev.help}`);
        }
        return MigrateDev.help;
    }
}
exports.MigrateDev = MigrateDev;
MigrateDev.help = sdk_1.format(`
${process.platform === 'win32' ? '' : chalk_1.default.bold('üèãÔ∏è  ')}Create a migration from changes in Prisma schema, apply it to the database, trigger generators (e.g. Prisma Client)
 
${chalk_1.default.bold('Usage')}

  ${chalk_1.default.dim('$')} prisma migrate dev [options]

${chalk_1.default.bold('Options')}

       -h, --help   Display this help message
         --schema   Custom path to your Prisma schema
       -n, --name   Name the migration
    --create-only   Create a new migration but do not apply it
                    The migration will be empty if there are no changes in Prisma schema
  --skip-generate   Skip triggering generators (e.g. Prisma Client)
      --skip-seed   Skip triggering seed

${chalk_1.default.bold('Examples')}

  Create a migration from changes in Prisma schema, apply it to the database, trigger generators (e.g. Prisma Client)
  ${chalk_1.default.dim('$')} prisma migrate dev

  Specify a schema
  ${chalk_1.default.dim('$')} prisma migrate dev --schema=./schema.prisma

  Create a migration without applying it
  ${chalk_1.default.dim('$')} prisma migrate dev --create-only
  `);
//# sourceMappingURL=MigrateDev.js.map