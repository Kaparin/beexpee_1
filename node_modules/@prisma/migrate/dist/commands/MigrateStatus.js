"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.MigrateStatus = void 0;
const sdk_1 = require("@prisma/sdk");
const chalk_1 = __importDefault(require("chalk"));
const path_1 = __importDefault(require("path"));
const ensureDatabaseExists_1 = require("../utils/ensureDatabaseExists");
const Migrate_1 = require("../Migrate");
const flagErrors_1 = require("../utils/flagErrors");
const errors_1 = require("../utils/errors");
const debug_1 = __importDefault(require("@prisma/debug"));
const detectOldMigrate_1 = require("../utils/detectOldMigrate");
const printDatasource_1 = require("../utils/printDatasource");
const debug = debug_1.default('prisma:migrate:status');
class MigrateStatus {
    static new() {
        return new MigrateStatus();
    }
    async parse(argv) {
        var _a, _b, _c, _d, _e;
        const args = sdk_1.arg(argv, {
            '--help': Boolean,
            '-h': '--help',
            '--experimental': Boolean,
            '--early-access-feature': Boolean,
            '--schema': String,
            '--telemetry-information': String,
        }, false);
        if (sdk_1.isError(args)) {
            return this.help(args.message);
        }
        if (args['--help']) {
            return this.help();
        }
        if (args['--experimental']) {
            throw new flagErrors_1.ExperimentalFlagWithNewMigrateError();
        }
        if (args['--early-access-feature']) {
            throw new flagErrors_1.EarlyAccessFeatureFlagWithNewMigrateError();
        }
        const schemaPath = await sdk_1.getSchemaPath(args['--schema']);
        if (!schemaPath) {
            throw new errors_1.NoSchemaFoundError();
        }
        console.info(chalk_1.default.dim(`Prisma schema loaded from ${path_1.default.relative(process.cwd(), schemaPath)}`));
        await printDatasource_1.printDatasource(schemaPath);
        detectOldMigrate_1.throwUpgradeErrorIfOldMigrate(schemaPath);
        const migrate = new Migrate_1.Migrate(schemaPath);
        try {
            await ensureDatabaseExists_1.ensureCanConnectToDatabase(schemaPath);
        }
        catch (e) {
            console.info(); // empty line
            return chalk_1.default.red(`Database connection error:

${e.message}`);
        }
        // This is a *read-only* command (modulo shadow database).
        // - ↩️ **RPC**: ****`diagnoseMigrationHistory`, then four cases based on the response.
        //     4. Otherwise, there is no problem migrate is aware of. We could still display:
        //         - Modified since applied only relevant when using dev, they are ignored for deploy
        //         - Pending migrations (those in the migrations folder that haven't been applied yet)
        //         - If there are no pending migrations, tell the user everything looks OK and up to date.
        const diagnoseResult = await migrate.diagnoseMigrationHistory({
            optInToShadowDatabase: false,
        });
        debug({ diagnoseResult: JSON.stringify(diagnoseResult, null, 2) });
        const listMigrationDirectoriesResult = await migrate.listMigrationDirectories();
        debug({ listMigrationDirectoriesResult });
        migrate.stop();
        console.log(); // empty line
        if (listMigrationDirectoriesResult.migrations.length > 0) {
            const migrations = listMigrationDirectoriesResult.migrations;
            console.info(`${migrations.length} migration${migrations.length > 1 ? 's' : ''} found in prisma/migrations\n`);
        }
        else {
            console.info(`No migration found in prisma/migrations\n`);
        }
        let unappliedMigrations = [];
        if (((_a = diagnoseResult.history) === null || _a === void 0 ? void 0 : _a.diagnostic) === 'databaseIsBehind') {
            unappliedMigrations = diagnoseResult.history.unappliedMigrationNames;
            console.info(`Following migration${unappliedMigrations.length > 1 ? 's' : ''} have not yet been applied:
${unappliedMigrations.join('\n')}

To apply migrations in development run ${chalk_1.default.bold.greenBright(sdk_1.getCommandWithExecutor(`prisma migrate dev`))}.
To apply migrations in production run ${chalk_1.default.bold.greenBright(sdk_1.getCommandWithExecutor(`prisma migrate deploy`))}.`);
        }
        else if (((_b = diagnoseResult.history) === null || _b === void 0 ? void 0 : _b.diagnostic) === 'historiesDiverge') {
            return `Your local migration history and the migrations table from your database are different:

The last common migration is: ${diagnoseResult.history.lastCommonMigrationName}

The migration${diagnoseResult.history.unappliedMigrationNames.length > 1 ? 's' : ''} have not yet been applied:
${diagnoseResult.history.unappliedMigrationNames.join('\n')}

The migration${diagnoseResult.history.unpersistedMigrationNames.length > 1 ? 's' : ''} from the database are not found locally in prisma/migrations:
${diagnoseResult.history.unpersistedMigrationNames.join('\n')}`;
        }
        if (!diagnoseResult.hasMigrationsTable) {
            //         - This is the **baselining** case.
            //         - Look at the migrations in the migrations folder
            //             - There is no local migration
            //                 - ...and there is drift: the user is coming from db push or another migration tool.
            //                 - Guide the user to an init flow with introspect + SQL schema dump (optionally)
            //             - There are local migrations
            //                 - ↩️ **RPC** `listMigrationDirectories` ****Take the first (=oldest) migration.
            //                 - Suggest calling `prisma migrate resolve --applied <migration-name>`
            if (listMigrationDirectoriesResult.migrations.length === 0) {
                return new errors_1.HowToBaselineError().message;
            }
            else {
                const migrationId = listMigrationDirectoriesResult.migrations.shift();
                return `The current database is not managed by Prisma Migrate.

If you want to keep the current database structure and data and create new migrations, baseline this database with the migration "${migrationId}":
${chalk_1.default.bold.greenBright(sdk_1.getCommandWithExecutor(`prisma migrate resolve --applied "${migrationId}"`))}

Read more about how to baseline an existing production database:
https://pris.ly/d/migrate-baseline`;
            }
        }
        else if (diagnoseResult.failedMigrationNames.length > 0) {
            //         - This is the **recovering from a partially failed migration** case.
            //         - Look at `drift.DriftDetected.rollback`. If present: display the rollback script
            //         - Inform the user that they can "close the case" and mark the failed migration as fixed by calling `prisma migrate resolve`.
            //             - `prisma migrate resolve --rolled-back <migration-name>` if the migration was rolled back
            //             - `prisma migrate resolve --applied <migration-name>` if the migration was rolled forward (and completed successfully)
            const failedMigrations = diagnoseResult.failedMigrationNames;
            console.info(`Following migration${failedMigrations.length > 1 ? 's' : ''} have failed:
${failedMigrations.join('\n')}

During development if the failed migration(s) have not been deployed to a production database you can then fix the migration(s) and run ${chalk_1.default.bold.greenBright(sdk_1.getCommandWithExecutor(`prisma migrate dev`))}.\n`);
            if (((_c = diagnoseResult.drift) === null || _c === void 0 ? void 0 : _c.diagnostic) === 'driftDetected' &&
                diagnoseResult.drift.rollback) {
                console.info(`Prisma Migrate generated a script to do a manual rollback
${chalk_1.default.grey(diagnoseResult.drift.rollback)}`);
            }
            return `The failed migration(s) can be marked as rolled back or applied:
      
- If you rolled back the migration(s) manually:
${chalk_1.default.bold.greenBright(sdk_1.getCommandWithExecutor(`prisma migrate resolve --rolled-back "${failedMigrations[0]}"`))}

- If you fixed the database manually (hotfix):
${chalk_1.default.bold.greenBright(sdk_1.getCommandWithExecutor(`prisma migrate resolve --applied "${failedMigrations[0]}"`))}

Read more about how to resolve migration issues in a production database:
https://pris.ly/d/migrate-resolve`;
        }
        else if (((_d = diagnoseResult.drift) === null || _d === void 0 ? void 0 : _d.diagnostic) === 'driftDetected' &&
            ((_e = diagnoseResult.history) === null || _e === void 0 ? void 0 : _e.diagnostic) === 'databaseIsBehind') {
            //         - Display the rollback script as an account of the contents of the drift.
            //         - Inform the user about scenarios
            //             - *User wants the changes in their local history:* tell the user they can reintrospect and call prisma migrate to create a new migration matching the detected changes
            //             - *User committed the changes in a migration and applied them outside of prisma migrate:* mark a migration that isn't applied yet as applied (hotfix case).
            //                 - Say they may want to `prisma migrate resolve --applied <migration-name>`, where `migration-name` is one of the migrations in `unappliedMigrations` in the `diagnoseMigrationHistory` result.
            const migrationId = diagnoseResult.history.unappliedMigrationNames;
            return `The current database schema is not in sync with your Prisma schema.
This is the script to roll back manually:
${chalk_1.default.grey(diagnoseResult.drift.rollback)}

You have 2 options

1. To keep the database structure change run: 
- ${chalk_1.default.bold.greenBright(sdk_1.getCommandWithExecutor('prisma db pull'))} to update your schema with the change.
- ${chalk_1.default.bold.greenBright(sdk_1.getCommandWithExecutor('prisma migrate dev'))} to create a new migration matching the change.
      
2. You corrected the change in a migration but applied it to the database without using Migrate (hotfix):
- ${chalk_1.default.bold.greenBright(sdk_1.getCommandWithExecutor(`prisma migrate resolve --applied "${migrationId}"`))} to create a new migration matching the change.`;
        }
        else {
            console.info(); // empty line
            if (unappliedMigrations.length > 0) {
                // state is not up to date
                return ``;
            }
            else {
                return `Database schema is up to date!`;
            }
        }
    }
    help(error) {
        if (error) {
            return new sdk_1.HelpError(`\n${chalk_1.default.bold.red(`!`)} ${error}\n${MigrateStatus.help}`);
        }
        return MigrateStatus.help;
    }
}
exports.MigrateStatus = MigrateStatus;
MigrateStatus.help = sdk_1.format(`
Check the status of your database migrations

  ${chalk_1.default.bold('Usage')}

    ${chalk_1.default.dim('$')} prisma migrate status [options]
    
  ${chalk_1.default.bold('Options')}

  -h, --help   Display this help message
    --schema   Custom path to your Prisma schema

  ${chalk_1.default.bold('Examples')}

  Check the status of your database migrations
  ${chalk_1.default.dim('$')} prisma migrate status

  Specify a schema
  ${chalk_1.default.dim('$')} prisma migrate status --schema=./schema.prisma
`);
//# sourceMappingURL=MigrateStatus.js.map