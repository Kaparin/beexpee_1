"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.MigrateReset = void 0;
const sdk_1 = require("@prisma/sdk");
const chalk_1 = __importDefault(require("chalk"));
const path_1 = __importDefault(require("path"));
const prompts_1 = __importDefault(require("prompts"));
const Migrate_1 = require("../Migrate");
const flagErrors_1 = require("../utils/flagErrors");
const errors_1 = require("../utils/errors");
const printFiles_1 = require("../utils/printFiles");
const detectOldMigrate_1 = require("../utils/detectOldMigrate");
const ensureDatabaseExists_1 = require("../utils/ensureDatabaseExists");
const printDatasource_1 = require("../utils/printDatasource");
const seed_1 = require("../utils/seed");
class MigrateReset {
    static new() {
        return new MigrateReset();
    }
    async parse(argv) {
        var _a;
        const args = sdk_1.arg(argv, {
            '--help': Boolean,
            '-h': '--help',
            '--force': Boolean,
            '-f': '--force',
            '--skip-generate': Boolean,
            '--skip-seed': Boolean,
            '--experimental': Boolean,
            '--early-access-feature': Boolean,
            '--schema': String,
            '--telemetry-information': String,
        });
        if (sdk_1.isError(args)) {
            return this.help(args.message);
        }
        if (args['--help']) {
            return this.help();
        }
        if (args['--experimental']) {
            throw new flagErrors_1.ExperimentalFlagWithNewMigrateError();
        }
        if (args['--early-access-feature']) {
            throw new flagErrors_1.EarlyAccessFeatureFlagWithNewMigrateError();
        }
        const schemaPath = await sdk_1.getSchemaPath(args['--schema']);
        if (!schemaPath) {
            throw new errors_1.NoSchemaFoundError();
        }
        console.info(chalk_1.default.dim(`Prisma schema loaded from ${path_1.default.relative(process.cwd(), schemaPath)}`));
        await printDatasource_1.printDatasource(schemaPath);
        console.info(); // empty line
        detectOldMigrate_1.throwUpgradeErrorIfOldMigrate(schemaPath);
        // Automatically create the database if it doesn't exist
        const wasDbCreated = await ensureDatabaseExists_1.ensureDatabaseExists('create', true, schemaPath);
        if (wasDbCreated) {
            console.info(wasDbCreated);
        }
        if (!args['--force']) {
            // We use prompts.inject() for testing in our CI
            if (sdk_1.isCi() && Boolean((_a = prompts_1.default._injected) === null || _a === void 0 ? void 0 : _a.length) === false) {
                throw new errors_1.MigrateResetEnvNonInteractiveError();
            }
            console.info(); // empty line
            const confirmation = await prompts_1.default({
                type: 'confirm',
                name: 'value',
                message: `Are you sure you want to reset your database? ${chalk_1.default.red('All data will be lost')}.`,
            });
            if (!confirmation.value) {
                console.info('Reset cancelled.');
                process.exit(0);
                // For snapshot test, because exit() is mocked
                return ``;
            }
        }
        const migrate = new Migrate_1.Migrate(schemaPath);
        await migrate.reset();
        const { appliedMigrationNames: migrationIds, } = await migrate.applyMigrations();
        migrate.stop();
        if (migrationIds.length === 0) {
            console.info(`${chalk_1.default.green('Database reset successful')}`);
        }
        else {
            console.info(`${chalk_1.default.green('Database reset successful')}

The following migration(s) have been applied:\n\n${chalk_1.default(printFiles_1.printFilesFromMigrationIds('migrations', migrationIds, {
                'migration.sql': '',
            }))}`);
        }
        // Run if not skipped
        if (!process.env.MIGRATE_SKIP_GENERATE && !args['--skip-generate']) {
            await migrate.tryToRunGenerate();
        }
        // Run if not skipped
        if (!process.env.MIGRATE_SKIP_SEED && !args['--skip-seed']) {
            // Run seed if 1 or more seed files are present
            const detected = seed_1.detectSeedFiles(schemaPath);
            if (detected.numberOfSeedFiles > 0) {
                await seed_1.tryToRunSeed(schemaPath);
            }
        }
        return ``;
    }
    help(error) {
        if (error) {
            return new sdk_1.HelpError(`\n${chalk_1.default.bold.red(`!`)} ${error}\n${MigrateReset.help}`);
        }
        return MigrateReset.help;
    }
}
exports.MigrateReset = MigrateReset;
MigrateReset.help = sdk_1.format(`
Reset your database and apply all migrations, all data will be lost

${chalk_1.default.bold('Usage')}

  ${chalk_1.default.dim('$')} prisma migrate reset [options]

${chalk_1.default.bold('Options')}

       -h, --help   Display this help message
         --schema   Custom path to your Prisma schema
  --skip-generate   Skip triggering generators (e.g. Prisma Client)
      --skip-seed   Skip triggering seed
      -f, --force   Skip the confirmation prompt

${chalk_1.default.bold('Examples')}

  Reset your database and apply all migrations, all data will be lost
  ${chalk_1.default.dim('$')} prisma migrate reset

  Specify a schema
  ${chalk_1.default.dim('$')} prisma migrate reset --schema=./schema.prisma 

  Use --force to skip the confirmation prompt
  ${chalk_1.default.dim('$')} prisma migrate reset --force
  `);
//# sourceMappingURL=MigrateReset.js.map