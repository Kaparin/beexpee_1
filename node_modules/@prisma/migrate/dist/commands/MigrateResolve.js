"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.MigrateResolve = void 0;
const sdk_1 = require("@prisma/sdk");
const chalk_1 = __importDefault(require("chalk"));
const path_1 = __importDefault(require("path"));
const ensureDatabaseExists_1 = require("../utils/ensureDatabaseExists");
const Migrate_1 = require("../Migrate");
const flagErrors_1 = require("../utils/flagErrors");
const errors_1 = require("../utils/errors");
const detectOldMigrate_1 = require("../utils/detectOldMigrate");
const printDatasource_1 = require("../utils/printDatasource");
class MigrateResolve {
    static new() {
        return new MigrateResolve();
    }
    async parse(argv) {
        const args = sdk_1.arg(argv, {
            '--help': Boolean,
            '-h': '--help',
            '--applied': String,
            '--rolled-back': String,
            '--experimental': Boolean,
            '--early-access-feature': Boolean,
            '--schema': String,
            '--telemetry-information': String,
        }, false);
        if (sdk_1.isError(args)) {
            return this.help(args.message);
        }
        if (args['--help']) {
            return this.help();
        }
        if (args['--experimental']) {
            throw new flagErrors_1.ExperimentalFlagWithNewMigrateError();
        }
        if (args['--early-access-feature']) {
            throw new flagErrors_1.EarlyAccessFeatureFlagWithNewMigrateError();
        }
        const schemaPath = await sdk_1.getSchemaPath(args['--schema']);
        if (!schemaPath) {
            throw new errors_1.NoSchemaFoundError();
        }
        console.info(chalk_1.default.dim(`Prisma schema loaded from ${path_1.default.relative(process.cwd(), schemaPath)}`));
        await printDatasource_1.printDatasource(schemaPath);
        detectOldMigrate_1.throwUpgradeErrorIfOldMigrate(schemaPath);
        // if both are not defined
        if (!args['--applied'] && !args['--rolled-back']) {
            throw new Error(`--applied or --rolled-back must be part of the command like:
${chalk_1.default.bold.green(sdk_1.getCommandWithExecutor('prisma migrate resolve --applied 20201231000000_example'))}
${chalk_1.default.bold.green(sdk_1.getCommandWithExecutor('prisma migrate resolve --rolled-back 20201231000000_example'))}`);
        }
        // if both are defined
        else if (args['--applied'] && args['--rolled-back']) {
            throw new Error('Pass either --applied or --rolled-back, not both.');
        }
        if (args['--applied']) {
            if (typeof args['--applied'] !== 'string' ||
                args['--applied'].length === 0) {
                throw new Error(`--applied value must be a string like ${chalk_1.default.bold.green(sdk_1.getCommandWithExecutor('prisma migrate resolve --applied 20201231000000_example'))}`);
            }
            await ensureDatabaseExists_1.ensureCanConnectToDatabase(schemaPath);
            const migrate = new Migrate_1.Migrate(schemaPath);
            await migrate.markMigrationApplied({
                migrationId: args['--applied'],
            });
            migrate.stop();
            return `Migration ${args['--applied']} marked as applied.`;
        }
        else {
            if (typeof args['--rolled-back'] !== 'string' ||
                args['--rolled-back'].length === 0) {
                throw new Error(`--rolled-back value must be a string like ${chalk_1.default.bold.green(sdk_1.getCommandWithExecutor('prisma migrate resolve --rolled-back 20201231000000_example'))}`);
            }
            await ensureDatabaseExists_1.ensureCanConnectToDatabase(schemaPath);
            const migrate = new Migrate_1.Migrate(schemaPath);
            await migrate.markMigrationRolledBack({
                migrationId: args['--rolled-back'],
            });
            migrate.stop();
            return `Migration ${args['--rolled-back']} marked as rolled back.`;
        }
    }
    help(error) {
        if (error) {
            return new sdk_1.HelpError(`\n${chalk_1.default.bold.red(`!`)} ${error}\n${MigrateResolve.help}`);
        }
        return MigrateResolve.help;
    }
}
exports.MigrateResolve = MigrateResolve;
MigrateResolve.help = sdk_1.format(`
Resolve issues with database migrations in deployment databases: 
- recover from failed migrations
- baseline databases when starting to use Prisma Migrate on existing databases
- reconcile hotfixes done manually on databases with your migration history

Run "prisma migrate status" to identify if you need to use resolve.

Read more about resolving migration history issues: ${sdk_1.link('https://pris.ly/d/migrate-resolve')}
 
${chalk_1.default.bold('Usage')}

  ${chalk_1.default.dim('$')} prisma migrate resolve [options]
  
${chalk_1.default.bold('Options')}

    -h, --help   Display this help message
      --schema   Custom path to your Prisma schema
     --applied   Record a specific migration as applied
 --rolled-back   Record a specific migration as rolled back

${chalk_1.default.bold('Examples')}

  Update migrations table, recording a specific migration as applied 
  ${chalk_1.default.dim('$')} prisma migrate resolve --applied 20201231000000_add_users_table

  Update migrations table, recording a specific migration as rolled back
  ${chalk_1.default.dim('$')} prisma migrate resolve --rolled-back 20201231000000_add_users_table

  Specify a schema
  ${chalk_1.default.dim('$')} prisma migrate resolve --rolled-back 20201231000000_add_users_table --schema=./schema.prisma
`);
//# sourceMappingURL=MigrateResolve.js.map