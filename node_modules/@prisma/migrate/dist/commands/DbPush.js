"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.DbPush = void 0;
const sdk_1 = require("@prisma/sdk");
const path_1 = __importDefault(require("path"));
const chalk_1 = __importDefault(require("chalk"));
const prompts_1 = __importDefault(require("prompts"));
const Migrate_1 = require("../Migrate");
const ensureDatabaseExists_1 = require("../utils/ensureDatabaseExists");
const formatms_1 = require("../utils/formatms");
const flagErrors_1 = require("../utils/flagErrors");
const errors_1 = require("../utils/errors");
const printDatasource_1 = require("../utils/printDatasource");
class DbPush {
    static new() {
        return new DbPush();
    }
    async parse(argv) {
        var _a, _b;
        const args = sdk_1.arg(argv, {
            '--help': Boolean,
            '-h': '--help',
            '--preview-feature': Boolean,
            '--accept-data-loss': Boolean,
            '--force-reset': Boolean,
            '--skip-generate': Boolean,
            '--schema': String,
            '--telemetry-information': String,
            // Deprecated
            // --force renamed to --accept-data-loss in 2.17.0
            '--force': Boolean,
            '-f': '--force',
        }, false);
        if (sdk_1.isError(args)) {
            return this.help(args.message);
        }
        if (args['--help']) {
            return this.help();
        }
        if (!args['--preview-feature']) {
            throw new flagErrors_1.PreviewFlagError();
        }
        if (args['--force']) {
            throw new errors_1.DbPushForceFlagRenamedError();
        }
        const schemaPath = await sdk_1.getSchemaPath(args['--schema']);
        if (!schemaPath) {
            throw new errors_1.NoSchemaFoundError();
        }
        console.info(chalk_1.default.dim(`Prisma schema loaded from ${path_1.default.relative(process.cwd(), schemaPath)}`));
        await printDatasource_1.printDatasource(schemaPath);
        const dbInfo = await ensureDatabaseExists_1.getDbInfo(schemaPath);
        const migrate = new Migrate_1.Migrate(schemaPath);
        let wasDatabaseReset = false;
        if (args['--force-reset']) {
            console.info();
            await migrate.reset();
            console.info(`The ${dbInfo.dbType} ${dbInfo.schemaWord} "${dbInfo.dbName}" from "${dbInfo.dbLocation}" was successfully reset.`);
            wasDatabaseReset = true;
        }
        // Automatically create the database if it doesn't exist
        const wasDbCreated = await ensureDatabaseExists_1.ensureDatabaseExists('push', true, schemaPath);
        if (wasDbCreated) {
            console.info();
            console.info(wasDbCreated);
        }
        const before = Date.now();
        const migration = await migrate.push({
            force: args['--accept-data-loss'],
        });
        if (migration.unexecutable && migration.unexecutable.length > 0) {
            const messages = [];
            messages.push(`${chalk_1.default.bold.red('\n‚ö†Ô∏è We found changes that cannot be executed:\n')}`);
            for (const item of migration.unexecutable) {
                messages.push(`${chalk_1.default(`  ‚Ä¢ ${item}`)}`);
            }
            console.info(); // empty line
            // We use prompts.inject() for testing in our CI
            if (sdk_1.isCi() && Boolean((_a = prompts_1.default._injected) === null || _a === void 0 ? void 0 : _a.length) === false) {
                migrate.stop();
                throw new Error(`${messages.join('\n')}\n
Use the --force-reset flag to drop the database before push like ${chalk_1.default.bold.greenBright(sdk_1.getCommandWithExecutor('prisma db push --preview-feature --force-reset'))}
${chalk_1.default.bold.redBright('All data will be lost.')}
        `);
            }
            else {
                console.info(`${messages.join('\n')}\n`);
            }
            console.info(); // empty line
            const confirmation = await prompts_1.default({
                type: 'confirm',
                name: 'value',
                message: `To apply this unexecutable migration we need to reset the database, do you want to continue? ${chalk_1.default.red('All data will be lost')}.`,
            });
            if (!confirmation.value) {
                console.info('Reset cancelled.');
                migrate.stop();
                process.exit(0);
                // For snapshot test, because exit() is mocked
                return ``;
            }
            await migrate.reset();
            console.info(`The ${dbInfo.dbType} ${dbInfo.schemaWord} "${dbInfo.dbName}" from "${dbInfo.dbLocation}" was successfully reset.`);
            wasDatabaseReset = true;
        }
        if (migration.warnings && migration.warnings.length > 0) {
            console.info(chalk_1.default.bold.yellow(`\n‚ö†Ô∏è  There might be data loss when applying the changes:\n`));
            for (const warning of migration.warnings) {
                console.info(chalk_1.default(`  ‚Ä¢ ${warning}`));
            }
            console.info(); // empty line
            if (!args['--accept-data-loss']) {
                // We use prompts.inject() for testing in our CI
                if (sdk_1.isCi() && Boolean((_b = prompts_1.default._injected) === null || _b === void 0 ? void 0 : _b.length) === false) {
                    migrate.stop();
                    throw new errors_1.DbPushIgnoreWarningsWithFlagError();
                }
                console.info(); // empty line
                const confirmation = await prompts_1.default({
                    type: 'confirm',
                    name: 'value',
                    message: `Do you want to ignore the warning(s)? ${chalk_1.default.red('Some data will be lost')}.`,
                });
                if (!confirmation.value) {
                    console.info('Push cancelled.');
                    migrate.stop();
                    process.exit(0);
                    // For snapshot test, because exit() is mocked
                    return ``;
                }
                await migrate.push({
                    force: true,
                });
            }
        }
        migrate.stop();
        if (!wasDatabaseReset &&
            migration.warnings.length === 0 &&
            migration.executedSteps === 0) {
            console.info(`\nThe database is already in sync with the Prisma schema.`);
        }
        else {
            console.info(`\n${process.platform === 'win32' ? '' : 'üöÄ  '}Your database is now in sync with your schema. Done in ${formatms_1.formatms(Date.now() - before)}`);
        }
        // Run if not skipped
        if (!process.env.MIGRATE_SKIP_GENERATE && !args['--skip-generate']) {
            await migrate.tryToRunGenerate();
        }
        return ``;
    }
    help(error) {
        if (error) {
            return new sdk_1.HelpError(`\n${chalk_1.default.bold.red(`!`)} ${error}\n${DbPush.help}`);
        }
        return DbPush.help;
    }
}
exports.DbPush = DbPush;
DbPush.help = sdk_1.format(`
${process.platform === 'win32' ? '' : chalk_1.default.bold('üôå  ')}Push the state from your Prisma schema to your database

${chalk_1.default.bold.yellow('WARNING')} ${chalk_1.default.bold(`Prisma db push is currently in Preview (${sdk_1.link('https://pris.ly/d/preview')}).
There may be bugs and it's not recommended to use it in production environments.`)}
${chalk_1.default.dim('When using any of the subcommands below you need to explicitly opt-in via the --preview-feature flag.')}

${chalk_1.default.bold('Usage')}

  ${chalk_1.default.dim('$')} prisma db push [options] --preview-feature

${chalk_1.default.bold('Options')}

           -h, --help   Display this help message
             --schema   Custom path to your Prisma schema
   --accept-data-loss   Ignore data loss warnings
        --force-reset   Force a reset of the database before push 
      --skip-generate   Skip triggering generators (e.g. Prisma Client)

${chalk_1.default.bold('Examples')}

  Push the Prisma schema state to the database
  ${chalk_1.default.dim('$')} prisma db push --preview-feature

  Specify a schema
  ${chalk_1.default.dim('$')} prisma db push --schema=./schema.prisma --preview-feature

  Ignore data loss warnings
  ${chalk_1.default.dim('$')} prisma db push --accept-data-loss --preview-feature
`);
//# sourceMappingURL=DbPush.js.map