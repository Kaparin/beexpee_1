"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Migrate = void 0;
const sdk_1 = require("@prisma/sdk");
const chalk_1 = __importDefault(require("chalk"));
const debug_1 = __importDefault(require("@prisma/debug"));
const fs_1 = __importDefault(require("fs"));
const log_update_1 = __importDefault(require("log-update"));
const path_1 = __importDefault(require("path"));
const MigrateEngine_1 = require("./MigrateEngine");
const formatms_1 = require("./utils/formatms");
const ensureDatabaseExists_1 = require("./utils/ensureDatabaseExists");
const engines_version_1 = require("@prisma/engines-version");
const errors_1 = require("./utils/errors");
const debug = debug_1.default('prisma:migrate');
const packageJson = eval(`require('../package.json')`); // tslint:disable-line
class Migrate {
    constructor(schemaPath, enabledPreviewFeatures) {
        this.schemaPath = this.getSchemaPath(schemaPath);
        this.migrationsDirectoryPath = path_1.default.join(path_1.default.dirname(this.schemaPath), 'migrations');
        this.engine = new MigrateEngine_1.MigrateEngine({
            projectDir: path_1.default.dirname(this.schemaPath),
            schemaPath: this.schemaPath,
            enabledPreviewFeatures,
        });
    }
    get devMigrationsDir() {
        return path_1.default.join(path_1.default.dirname(this.schemaPath), 'migrations/dev');
    }
    stop() {
        this.engine.stop();
    }
    getSchemaPath(schemaPathFromOptions) {
        const schemaPath = sdk_1.getSchemaPathSync(schemaPathFromOptions);
        if (!schemaPath) {
            throw new errors_1.NoSchemaFoundError();
        }
        return schemaPath;
    }
    getDatamodel() {
        return fs_1.default.readFileSync(this.schemaPath, 'utf-8');
    }
    reset() {
        return this.engine.reset();
    }
    createMigration(params) {
        return this.engine.createMigration(params);
    }
    diagnoseMigrationHistory({ optInToShadowDatabase, }) {
        return this.engine.diagnoseMigrationHistory({
            migrationsDirectoryPath: this.migrationsDirectoryPath,
            optInToShadowDatabase,
        });
    }
    async getDbInfo() {
        const datamodel = this.getDatamodel();
        const config = await sdk_1.getConfig({ datamodel });
        const activeDatasource = config.datasources[0];
        const credentials = sdk_1.uriToCredentials(activeDatasource.url.value);
        const dbLocation = ensureDatabaseExists_1.getDbLocation(credentials);
        return {
            ...ensureDatabaseExists_1.getDbinfoFromCredentials(credentials),
            dbLocation,
        };
    }
    listMigrationDirectories() {
        return this.engine.listMigrationDirectories({
            migrationsDirectoryPath: this.migrationsDirectoryPath,
        });
    }
    devDiagnostic() {
        return this.engine.devDiagnostic({
            migrationsDirectoryPath: this.migrationsDirectoryPath,
        });
    }
    async markMigrationApplied({ migrationId, }) {
        return await this.engine.markMigrationApplied({
            migrationsDirectoryPath: this.migrationsDirectoryPath,
            migrationName: migrationId,
        });
    }
    markMigrationRolledBack({ migrationId, }) {
        return this.engine.markMigrationRolledBack({
            migrationName: migrationId,
        });
    }
    applyMigrations() {
        return this.engine.applyMigrations({
            migrationsDirectoryPath: this.migrationsDirectoryPath,
        });
    }
    evaluateDataLoss() {
        const datamodel = this.getDatamodel();
        return this.engine.evaluateDataLoss({
            migrationsDirectoryPath: this.migrationsDirectoryPath,
            prismaSchema: datamodel,
        });
    }
    async push({ force = false, }) {
        const datamodel = this.getDatamodel();
        const { warnings, unexecutable, executedSteps, } = await this.engine.schemaPush({
            force,
            schema: datamodel,
        });
        return {
            executedSteps,
            warnings,
            unexecutable,
        };
    }
    async tryToRunGenerate() {
        var _a;
        const message = [];
        console.info(); // empty line
        log_update_1.default(`Running generate... ${chalk_1.default.dim('(Use --skip-generate to skip the generators)')}`);
        const generators = await sdk_1.getGenerators({
            schemaPath: this.schemaPath,
            printDownloadProgress: false,
            version: engines_version_1.enginesVersion,
            cliVersion: packageJson.version,
        });
        for (const generator of generators) {
            const toStr = generator.options.generator.output
                ? chalk_1.default.dim(` to .${path_1.default.sep}${path_1.default.relative(process.cwd(), generator.options.generator.output)}`)
                : '';
            const name = generator.manifest
                ? generator.manifest.prettyName
                : generator.options.generator.provider;
            log_update_1.default(`Running generate... - ${name}`);
            const before = Date.now();
            try {
                await generator.generate();
                const after = Date.now();
                const version = (_a = generator.manifest) === null || _a === void 0 ? void 0 : _a.version;
                message.push(`âœ” Generated ${chalk_1.default.bold(name)}${version ? ` (${version})` : ''}${toStr} in ${formatms_1.formatms(after - before)}`);
                generator.stop();
            }
            catch (err) {
                message.push(`${err.message}`);
                generator.stop();
            }
        }
        log_update_1.default(message.join('\n'));
    }
}
exports.Migrate = Migrate;
//# sourceMappingURL=Migrate.js.map