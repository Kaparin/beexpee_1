"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getScriptsFromPackageJson = exports.tryToRunSeed = exports.detectSeedFiles = exports.isPackageInstalledGlobally = void 0;
const fs_1 = __importDefault(require("fs"));
const path_1 = __importDefault(require("path"));
const execa_1 = __importDefault(require("execa"));
const resolve_pkg_1 = __importDefault(require("resolve-pkg"));
const has_yarn_1 = __importDefault(require("has-yarn"));
const chalk_1 = __importDefault(require("chalk"));
const global_dirs_1 = __importDefault(require("global-dirs"));
const pkg_up_1 = __importDefault(require("pkg-up"));
const util_1 = require("util");
const readFileAsync = util_1.promisify(fs_1.default.readFile);
function isPackageInstalledGlobally(packageName) {
    try {
        const usingGlobalYarn = fs_1.default.existsSync(path_1.default.join(global_dirs_1.default.yarn.packages, packageName));
        const usingGlobalNpm = fs_1.default.existsSync(path_1.default.join(global_dirs_1.default.npm.packages, packageName));
        if (usingGlobalNpm) {
            return 'npm';
        }
        if (usingGlobalYarn) {
            return 'yarn';
        }
        else {
            false;
        }
    }
    catch (e) {
        //
    }
    return false;
}
exports.isPackageInstalledGlobally = isPackageInstalledGlobally;
function detectSeedFiles(schemaPath) {
    let parentDirectory = path_1.default.relative(process.cwd(), path_1.default.join(process.cwd(), 'prisma'));
    if (schemaPath) {
        parentDirectory = path_1.default.relative(process.cwd(), path_1.default.dirname(schemaPath));
    }
    const seedPath = path_1.default.join(parentDirectory, 'seed.');
    const detected = {
        seedPath,
        numberOfSeedFiles: 0,
        js: '',
        ts: '',
        sh: '',
    };
    const extensions = ['js', 'ts', 'sh'];
    for (const extension of extensions) {
        const fullPath = seedPath + extension;
        if (!fs_1.default.existsSync(fullPath)) {
            continue;
        }
        detected[extension] = fullPath;
        detected.numberOfSeedFiles++;
    }
    return detected;
}
exports.detectSeedFiles = detectSeedFiles;
async function tryToRunSeed(schemaPath) {
    const detected = detectSeedFiles(schemaPath);
    if (detected.numberOfSeedFiles === 0) {
        throw new Error(`No seed file found.
Create a \`seed.ts\`, \`.js\` or \`.sh\` file in the prisma directory.`);
    }
    else if (detected.numberOfSeedFiles > 1) {
        throw new Error(`More than one seed file was found in \`${path_1.default.relative(process.cwd(), path_1.default.dirname(detected.seedPath))}\` directory.
This command only supports one seed file: Use \`seed.ts\`, \`.js\` or \`.sh\`.`);
    }
    else {
        if (detected.js) {
            console.info(`Running ${chalk_1.default.bold(`node "${detected.js}"`)} ...`);
            return await execa_1.default('node', [`"${detected.js}"`], {
                shell: true,
                stdio: 'inherit',
            });
        }
        else if (detected.ts) {
            const hasTypescriptPkg = resolve_pkg_1.default('typescript') || isPackageInstalledGlobally('typescript');
            const hasTsNodePkg = resolve_pkg_1.default('ts-node') || isPackageInstalledGlobally('ts-node');
            const hasTypesNodePkg = resolve_pkg_1.default('@types/node');
            const missingPkgs = [];
            if (!hasTypescriptPkg) {
                missingPkgs.push('typescript');
            }
            if (!hasTsNodePkg) {
                missingPkgs.push('ts-node');
            }
            if (!hasTypesNodePkg) {
                missingPkgs.push('@types/node');
            }
            if (missingPkgs.length > 0) {
                const packageManager = has_yarn_1.default() ? 'yarn add -D' : 'npm i -D';
                console.info(`We detected a seed file at \`${detected.ts}\` but it seems that you do not have the following dependencies installed:
${missingPkgs.map((name) => `- ${name}`).join('\n')}

To install them run: ${chalk_1.default.green(`${packageManager} ${missingPkgs.join(' ')}`)}\n`);
            }
            // Check package.json for a "ts-node" script (so users can customize flags)
            const scripts = await getScriptsFromPackageJson();
            let tsNodeCommand = 'ts-node';
            if (scripts === null || scripts === void 0 ? void 0 : scripts['ts-node']) {
                tsNodeCommand = scripts['ts-node'];
            }
            console.info(`Running ${chalk_1.default.bold(`${tsNodeCommand} "${detected.ts}"`)} ...`);
            return await execa_1.default(tsNodeCommand, [`"${detected.ts}"`], {
                shell: true,
                stdio: 'inherit',
            });
        }
        else if (detected.sh) {
            console.info(`Running ${chalk_1.default.bold(`sh "${detected.sh}"`)} ...`);
            return await execa_1.default('sh', [`"${detected.sh}"`], {
                shell: true,
                stdio: 'inherit',
            });
        }
    }
}
exports.tryToRunSeed = tryToRunSeed;
async function getScriptsFromPackageJson(cwd = process.cwd()) {
    try {
        const pkgJsonPath = await pkg_up_1.default({ cwd });
        if (!pkgJsonPath) {
            return null;
        }
        const pkgJsonString = await readFileAsync(pkgJsonPath, 'utf-8');
        const pkgJson = JSON.parse(pkgJsonString);
        // Pick and return only items we need
        const { 'ts-node': tsnode } = pkgJson.scripts;
        return { 'ts-node': tsnode };
    }
    catch (_a) {
        return null;
    }
}
exports.getScriptsFromPackageJson = getScriptsFromPackageJson;
//# sourceMappingURL=seed.js.map