"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.printDatamodelDiff = void 0;
const sdk_1 = require("@prisma/sdk");
const diff_1 = require("diff");
const chalk_1 = __importDefault(require("chalk"));
const customColors_1 = require("./customColors");
const strip_ansi_1 = __importDefault(require("strip-ansi"));
// TODO diff on trimmed text
function printDatamodelDiff(rawDatamodelA, rawDatamodelB) {
    const datamodelA = sdk_1.trimBlocksFromSchema(rawDatamodelA, [
        'source',
        'datasource',
        'generator',
    ]);
    if (!rawDatamodelB) {
        return sdk_1.highlightDatamodel(datamodelA);
    }
    const datamodelB = sdk_1.trimBlocksFromSchema(rawDatamodelB, [
        'source',
        'datasource',
        'generator',
    ]);
    let result = fixCurly(diff_1.diffLines(normalizeText(datamodelA), normalizeText(datamodelB)));
    result = result.map((diff) => ({ ...diff, value: sdk_1.trimNewLine(diff.value) }));
    const diff = result
        .map((change, index, changes) => {
        if (change.added) {
            if (change.value.split('\n').length <= 2 &&
                index > 0 &&
                changes[index - 1] &&
                changes[index - 1].removed) {
                const charChanges = diff_1.diffWords(changes[index - 1].value, change.value);
                if (charChanges.length < change.value.length - 4) {
                    return charChanges
                        .map((charChange) => {
                        if (charChange.added) {
                            return customColors_1.strongGreen(charChange.value);
                        }
                        if (charChange.removed) {
                            return '';
                        }
                        return chalk_1.default.greenBright(charChange.value);
                    })
                        .join('');
                }
            }
            return chalk_1.default.greenBright(change.value);
        }
        if (change.removed) {
            if (change.value.split('\n').length <= 2 &&
                index > 0 &&
                changes[index + 1] &&
                changes[index + 1].added &&
                changes[index + 1].value.split('\n').length <= 2) {
                const charChanges = diff_1.diffWords(change.value, changes[index + 1].value);
                if (charChanges.length < change.value.length - 3) {
                    return charChanges
                        .map((charChange) => {
                        if (charChange.removed) {
                            return customColors_1.strongRed(charChange.value);
                        }
                        if (charChange.added) {
                            return '';
                        }
                        return chalk_1.default.redBright(charChange.value);
                    })
                        .join('');
                }
            }
            return chalk_1.default.redBright(change.value);
        }
        return sdk_1.highlightDatamodel(sdk_1.trimBlocksFromSchema(change.value));
    })
        .join('\n')
        .trim();
    return trimMultiEmptyLines(diff);
}
exports.printDatamodelDiff = printDatamodelDiff;
// trims to consecutive empty lines from a string
function trimMultiEmptyLines(str) {
    const lines = str.split('\n');
    const newLines = [];
    let i = lines.length;
    while (i--) {
        const line = lines[i];
        const trimmed = line.trim();
        if (trimmed.length > 0) {
            newLines.unshift(line);
            continue;
        }
        // in this case it's an empty line
        // if the next line is also empty, remove this one
        if (lines[i - 1] && lines[i - 1].trim().length > 0) {
            newLines.unshift(line);
        }
    }
    return newLines.join('\n');
}
// filter unnecessary space changes
function normalizeText(str) {
    return (str
        .split('\n')
        .reduce((acc, line) => {
        const trimmed = line.trim();
        if (trimmed.startsWith('#')) {
            return acc;
        }
        if (trimmed.length <= 1) {
            acc.push(trimmed);
        }
        else {
            acc.push(removeSpacing(line)); // TODO normalize white spaces
        }
        return acc;
    }, [])
        .join('\n') + '\n');
}
function removeSpacing(line) {
    return removeDirectiveSpacing(removeValueSpacing(line));
}
function removeValueSpacing(line) {
    const match = /\b(\s+)\w+/g.exec(line);
    if (match && match[1].length > 1) {
        return (line.slice(0, match.index) +
            ' ' +
            line.slice(match.index + match[1].length));
    }
    return line;
}
function removeDirectiveSpacing(line) {
    const match = /(\s+)@/g.exec(line);
    if (match && match[1].length > 1) {
        return (line.slice(0, match.index) +
            ' ' +
            line.slice(match.index + match[1].length));
    }
    return line;
}
function fixCurly(changes) {
    return fixCurlyRemoved(fixCurlyRemovedDangling(fixCurlyAdded(changes)));
}
function fixCurlyAdded(changes) {
    changes.forEach((change, index) => {
        if (!change.added &&
            !change.removed &&
            change.value.trim() === '}' &&
            index > 0 &&
            changes[index - 1].added) {
            const correspondingIndex = changes.slice(0, index).findIndex((c) => {
                if (!c.added) {
                    return false;
                }
                let hasCloseBeforeOpen = false;
                const lines = c.value.split('\n');
                for (const line of lines) {
                    if (line.trim() === '}') {
                        hasCloseBeforeOpen = true;
                        break;
                    }
                }
                return hasCloseBeforeOpen;
            });
            if (correspondingIndex > -1) {
                const correspondingChange = changes[correspondingIndex];
                // 1. Merge our lonely curly with the added before and delete it
                changes[index - 1].value = changes[index - 1].value + change.value;
                changes.splice(index, 1);
                // 2. get rid of the unnecessary } in the corresponding block we just found
                // and turn it into a normal curly
                const lines = correspondingChange.value.split('\n');
                const indexOfWrongCurly = lines.findIndex((l) => l.trim() === '}');
                const newChanges = [
                    {
                        value: lines.slice(0, indexOfWrongCurly).join('\n'),
                        added: true,
                    },
                    {
                        value: strip_ansi_1.default(lines[indexOfWrongCurly]) + '\n\n',
                    },
                    {
                        value: lines.slice(indexOfWrongCurly + 1).join('\n'),
                        added: true,
                    },
                ];
                changes.splice(correspondingIndex, 1, ...newChanges);
            }
        }
    });
    return changes.filter((change) => change.value !== '');
}
function fixCurlyRemoved(changes) {
    changes.forEach((change, index) => {
        if (!change.added &&
            !change.removed &&
            change.value.trim() === '}' &&
            index > 0 &&
            changes[index - 1].removed) {
            const correspondingIndex = changes.slice(0, index).findIndex((c) => {
                if (!c.removed) {
                    return false;
                }
                let hasCloseBeforeOpen = false;
                const lines = c.value.split('\n');
                for (const line of lines) {
                    if (line.trim() === '}') {
                        hasCloseBeforeOpen = true;
                        break;
                    }
                }
                return hasCloseBeforeOpen;
            });
            if (correspondingIndex > -1) {
                const correspondingChange = changes[correspondingIndex];
                // 1. Merge our lonely curly with the removed before and delete it
                changes[index - 1].value = changes[index - 1].value + change.value;
                changes.splice(index, 1);
                // 2. get rid of the unnecessary } in the corresponding block we just found
                // and turn it into a normal curly
                const lines = correspondingChange.value.split('\n');
                const indexOfWrongCurly = lines.findIndex((l) => l.trim() === '}');
                const newChanges = [
                    {
                        value: lines.slice(0, indexOfWrongCurly).join('\n'),
                        removed: true,
                    },
                    {
                        value: strip_ansi_1.default(lines[indexOfWrongCurly]) + '\n\n',
                    },
                    {
                        value: lines.slice(indexOfWrongCurly + 1).join('\n'),
                        removed: true,
                    },
                ];
                changes.splice(correspondingIndex, 1, ...newChanges);
            }
        }
    });
    return changes.filter((change) => change.value !== '');
}
// // jsdiff spreads the } curly braces all over the place
// // we don't want that
function fixCurlyRemovedDangling(changes) {
    return changes.reduce((acc, change, index) => {
        if (change.removed &&
            change.value.trim() === '}' &&
            changes[index + 1] &&
            changes[index + 1].value.startsWith('}')) {
            return acc;
        }
        if (change.added && change.value.startsWith('}')) {
            const lastValue = acc.slice(-1)[0];
            if (lastValue) {
                acc[acc.indexOf(lastValue)] = {
                    ...lastValue,
                    value: lastValue.value + '}',
                };
                acc.push({
                    ...change,
                    value: change.value.slice(2), // trim away the } and the \n after that
                });
                return acc;
            }
        }
        acc.push(change);
        return acc;
    }, []);
}
//# sourceMappingURL=printDatamodelDiff.js.map