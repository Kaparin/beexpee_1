"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getDbinfoFromCredentials = exports.getDbLocation = exports.askToCreateDb = exports.interactivelyCreateDatabase = exports.ensureDatabaseExists = exports.ensureCanConnectToDatabase = exports.getDbInfo = void 0;
const sdk_1 = require("@prisma/sdk");
const sdk_2 = require("@prisma/sdk");
const chalk_1 = __importDefault(require("chalk"));
const sdk_3 = require("@prisma/sdk");
const prompts_1 = __importDefault(require("prompts"));
async function getDbInfo(schemaPath) {
    const datamodel = await sdk_1.getSchema(schemaPath);
    const config = await sdk_2.getConfig({ datamodel });
    const activeDatasource = config.datasources[0];
    const credentials = sdk_3.uriToCredentials(activeDatasource.url.value);
    const dbLocation = getDbLocation(credentials);
    const dbinfoFromCredentials = getDbinfoFromCredentials(credentials);
    return {
        name: activeDatasource.name,
        dbLocation,
        ...dbinfoFromCredentials,
        url: activeDatasource.url.value,
        schema: credentials.schema,
    };
}
exports.getDbInfo = getDbInfo;
async function ensureCanConnectToDatabase(schemaPath) {
    const datamodel = await sdk_1.getSchema(schemaPath);
    const config = await sdk_2.getConfig({ datamodel });
    const activeDatasource = config.datasources[0];
    if (!activeDatasource) {
        throw new Error(`Couldn't find a datasource in the schema.prisma file`);
    }
    const schemaDir = (await sdk_1.getSchemaDir(schemaPath));
    const canConnect = await sdk_3.canConnectToDatabase(activeDatasource.url.value, schemaDir);
    if (canConnect === true) {
        return true;
    }
    else {
        const { code, message } = canConnect;
        throw new Error(`${code}: ${message}`);
    }
}
exports.ensureCanConnectToDatabase = ensureCanConnectToDatabase;
async function ensureDatabaseExists(action, forceCreate = false, schemaPath) {
    const datamodel = await sdk_1.getSchema(schemaPath);
    const config = await sdk_2.getConfig({ datamodel });
    const activeDatasource = config.datasources[0];
    if (!activeDatasource) {
        throw new Error(`Couldn't find a datasource in the schema.prisma file`);
    }
    const schemaDir = (await sdk_1.getSchemaDir(schemaPath));
    const canConnect = await sdk_3.canConnectToDatabase(activeDatasource.url.value, schemaDir);
    if (canConnect === true) {
        return;
    }
    const { code, message } = canConnect;
    if (code !== 'P1003') {
        throw new Error(`${code}: ${message}`);
    }
    // last case: status === 'DatabaseDoesNotExist'
    if (!schemaDir) {
        throw new Error(`Could not locate ${schemaPath || 'schema.prisma'}`);
    }
    if (forceCreate) {
        const result = await sdk_3.createDatabase(activeDatasource.url.value, schemaDir);
        if (result && result.exitCode === 0) {
            const credentials = sdk_3.uriToCredentials(activeDatasource.url.value);
            const { schemaWord, dbType, dbName } = getDbinfoFromCredentials(credentials);
            return `${dbType} ${schemaWord} ${chalk_1.default.bold(dbName)} created at ${chalk_1.default.bold(getDbLocation(credentials))}\n`;
        }
    }
    else {
        await interactivelyCreateDatabase(activeDatasource.url.value, action, schemaDir);
    }
}
exports.ensureDatabaseExists = ensureDatabaseExists;
async function interactivelyCreateDatabase(connectionString, action, schemaDir) {
    await askToCreateDb(connectionString, action, schemaDir);
}
exports.interactivelyCreateDatabase = interactivelyCreateDatabase;
async function askToCreateDb(connectionString, action, schemaDir) {
    const credentials = sdk_3.uriToCredentials(connectionString);
    const { schemaWord, dbType, dbName } = getDbinfoFromCredentials(credentials);
    const message = `You are trying to ${action} a migration for ${dbType} ${schemaWord} ${chalk_1.default.bold(dbName)}.\nA ${schemaWord} with that name doesn't exist at ${chalk_1.default.bold(getDbLocation(credentials))}\n`;
    // empty line
    console.info();
    const response = await prompts_1.default({
        type: 'select',
        name: 'value',
        message: message,
        initial: 0,
        choices: [
            {
                title: 'Yes',
                value: true,
                description: `Create new ${dbType} ${schemaWord} ${chalk_1.default.bold(dbName)}`,
            },
            {
                title: 'No',
                value: false,
                description: `Don't create the ${schemaWord}`,
            },
        ],
    });
    if (response.value) {
        await sdk_3.createDatabase(connectionString, schemaDir);
    }
    else {
        process.exit(0);
    }
}
exports.askToCreateDb = askToCreateDb;
function getDbLocation(credentials) {
    if (credentials.type === 'sqlite') {
        return credentials.uri;
    }
    if (!credentials.port) {
        switch (credentials.type) {
            case 'mysql':
                credentials.port = 3306;
                break;
            case 'postgresql':
                credentials.port = 5432;
                break;
            case 'sqlserver':
                credentials.port = 1433;
                break;
        }
    }
    return `${credentials.host}:${credentials.port}`;
}
exports.getDbLocation = getDbLocation;
function getDbinfoFromCredentials(credentials) {
    const dbName = credentials.database;
    let dbType;
    switch (credentials.type) {
        case 'mysql':
            dbType = `MySQL`;
            break;
        case 'postgresql':
            dbType = `PostgreSQL`;
            break;
        case 'sqlite':
            dbType = `SQLite`;
            break;
        case 'mssql':
            dbType = `MSSQL`;
            break;
    }
    const schemaWord = 'database';
    return {
        dbName,
        dbType,
        schemaWord,
    };
}
exports.getDbinfoFromCredentials = getDbinfoFromCredentials;
//# sourceMappingURL=ensureDatabaseExists.js.map