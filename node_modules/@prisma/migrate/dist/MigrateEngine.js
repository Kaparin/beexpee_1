"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.MigrateEngine = exports.EngineError = void 0;
const chalk_1 = __importDefault(require("chalk"));
const child_process_1 = require("child_process");
const debug_1 = __importDefault(require("@prisma/debug"));
const byline_1 = __importDefault(require("./utils/byline"));
const debugRpc = debug_1.default('prisma:migrateEngine:rpc');
const debugStderr = debug_1.default('prisma:migrateEngine:stderr');
const debugStdin = debug_1.default('prisma:migrateEngine:stdin');
const fs_1 = __importDefault(require("fs"));
const now_1 = require("./utils/now");
const sdk_1 = require("@prisma/sdk");
class EngineError extends Error {
    constructor(message, code) {
        super(message);
        this.code = code;
    }
}
exports.EngineError = EngineError;
let messageId = 1;
/* tslint:disable */
class MigrateEngine {
    constructor({ projectDir, debug = false, schemaPath, enabledPreviewFeatures, }) {
        this.listeners = {};
        this.messages = [];
        this.projectDir = projectDir;
        this.schemaPath = schemaPath;
        if (debug) {
            debug_1.default.enable('MigrateEngine*');
        }
        this.debug = debug;
        this.enabledPreviewFeatures = enabledPreviewFeatures;
    }
    stop() {
        this.child.kill();
    }
    /* eslint-disable @typescript-eslint/no-unsafe-return */
    // Runs dev diagnostic
    devDiagnostic(args) {
        return this.runCommand(this.getRPCPayload('devDiagnostic', args));
    }
    // List migrations in migration directory.
    listMigrationDirectories(args) {
        return this.runCommand(this.getRPCPayload('listMigrationDirectories', args));
    }
    // Mark the specified migration as applied in the migrations table. There are two possible cases:
    // - The migration is already in the table, but in a failed state. In this case, we will mark it as rolled back, then create a new entry.
    // - The migration is not in the table. We will create a new entry in the migrations table. The `started_at` and `finished_at` will be the same.
    // - If it is already applied, we return a user-facing error.
    markMigrationApplied(args) {
        return this.runCommand(this.getRPCPayload('markMigrationApplied', args));
    }
    // Mark an existing failed migration as rolled back in the migrations table. It will still be there, but ignored for all purposes except as audit trail.
    markMigrationRolledBack(args) {
        return this.runCommand(this.getRPCPayload('markMigrationRolledBack', args));
    }
    diagnoseMigrationHistory(args) {
        return this.runCommand(this.getRPCPayload('diagnoseMigrationHistory', args));
    }
    planMigration(args) {
        return this.runCommand(this.getRPCPayload('planMigration', args));
    }
    evaluateDataLoss(args) {
        return this.runCommand(this.getRPCPayload('evaluateDataLoss', args));
    }
    createMigration(args) {
        return this.runCommand(this.getRPCPayload('createMigration', args));
    }
    applyMigrations(args) {
        return this.runCommand(this.getRPCPayload('applyMigrations', args));
    }
    reset() {
        return this.runCommand(this.getRPCPayload('reset', undefined));
    }
    getDatabaseVersion() {
        return this.runCommand(this.getRPCPayload('getDatabaseVersion', undefined));
    }
    schemaPush(args) {
        return this.runCommand(this.getRPCPayload('schemaPush', args));
    }
    debugPanic() {
        return this.runCommand(this.getRPCPayload('debugPanic', undefined));
    }
    /* eslint-enable @typescript-eslint/no-unsafe-return */
    rejectAll(err) {
        Object.entries(this.listeners).map(([id, listener]) => {
            listener(null, err);
            delete this.listeners[id];
        });
    }
    registerCallback(id, callback) {
        this.listeners[id] = callback;
    }
    handleResponse(response) {
        let result;
        try {
            result = JSON.parse(response);
        }
        catch (e) {
            console.error(`Could not parse migration engine response: ${response.slice(0, 200)}`);
        }
        if (result) {
            if (result.id) {
                if (!this.listeners[result.id]) {
                    console.error(`Got result for unknown id ${result.id}`);
                }
                if (this.listeners[result.id]) {
                    this.listeners[result.id](result);
                    delete this.listeners[result.id];
                }
            }
            else {
                // If the error happens before the JSON-RPC sever starts, the error doesn't have an id
                if (result.is_panic) {
                    throw new Error(`Response: ${result.message}`);
                }
                else if (result.message) {
                    console.error(chalk_1.default.red(`Response: ${result.message}`));
                }
                else {
                    console.error(chalk_1.default.red(`Response: ${JSON.stringify(result)}`));
                }
            }
        }
    }
    init() {
        if (!this.initPromise) {
            this.initPromise = this.internalInit();
        }
        return this.initPromise;
    }
    internalInit() {
        // eslint-disable-next-line @typescript-eslint/no-misused-promises, no-async-promise-executor
        return new Promise(async (resolve, reject) => {
            try {
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                const { PWD, ...rest } = process.env;
                const binaryPath = await sdk_1.resolveBinary('migration-engine');
                debugRpc('starting migration engine with binary: ' + binaryPath);
                const args = ['-d', this.schemaPath];
                if (this.enabledPreviewFeatures &&
                    Array.isArray(this.enabledPreviewFeatures) &&
                    this.enabledPreviewFeatures.length > 0) {
                    args.push(...[
                        '--enabled-preview-features',
                        this.enabledPreviewFeatures.join(','),
                    ]);
                }
                this.child = child_process_1.spawn(binaryPath, args, {
                    cwd: this.projectDir,
                    stdio: ['pipe', 'pipe', this.debug ? process.stderr : 'pipe'],
                    env: {
                        ...rest,
                        SERVER_ROOT: this.projectDir,
                        RUST_LOG: 'info',
                        RUST_BACKTRACE: '1',
                    },
                });
                this.child.on('error', (err) => {
                    console.error('[migration-engine] error: %s', err);
                    reject(err);
                    this.rejectAll(err);
                });
                this.child.on('exit', (code) => {
                    const messages = this.messages.join('\n');
                    let err;
                    if (code !== 0 || messages.includes('panicking')) {
                        let errorMessage = chalk_1.default.red.bold('Error in migration engine: ') + messages;
                        if (code === 250) {
                            // Not a panic
                            // It's a UserFacingError https://github.com/prisma/prisma-engines/pull/1446
                            errorMessage = chalk_1.default.red.bold('UserFacingError');
                        }
                        else if (this.lastError && code === 255) {
                            errorMessage = serializePanic(this.lastError);
                            err = new sdk_1.RustPanic(errorMessage, this.lastError.message, this.lastRequest, sdk_1.ErrorArea.LIFT_CLI, this.schemaPath);
                        }
                        else if (messages.includes('panicked at') || code === 255) {
                            err = new sdk_1.RustPanic(errorMessage, messages, this.lastRequest, sdk_1.ErrorArea.LIFT_CLI, this.schemaPath);
                        }
                        err = err || new Error(errorMessage);
                        this.rejectAll(err);
                        reject(err);
                    }
                });
                this.child.stdin.on('error', (err) => {
                    debugStdin(err);
                });
                byline_1.default(this.child.stderr).on('data', (data) => {
                    const msg = String(data);
                    this.messages.push(msg);
                    debugStderr(msg);
                    try {
                        const json = JSON.parse(msg);
                        if (json.backtrace) {
                            this.lastError = json;
                        }
                        if (json.level === 'ERRO') {
                            this.lastError = json;
                        }
                    }
                    catch (e) {
                        //
                    }
                });
                byline_1.default(this.child.stdout).on('data', (line) => {
                    this.handleResponse(String(line));
                });
                setImmediate(() => {
                    resolve();
                });
            }
            catch (e) {
                reject(e);
            }
        });
    }
    async runCommand(request) {
        var _a;
        if (process.env.FORCE_PANIC_MIGRATION_ENGINE) {
            request = this.getRPCPayload('debugPanic', undefined);
        }
        await this.init();
        if ((_a = this.child) === null || _a === void 0 ? void 0 : _a.killed) {
            throw new Error(`Can't execute ${JSON.stringify(request)} because migration engine already exited.`);
        }
        return new Promise((resolve, reject) => {
            this.registerCallback(request.id, (response, err) => {
                var _a, _b, _c, _d, _e, _f;
                if (err) {
                    return reject(err);
                }
                // can be null, for reset RPC for example
                if (response.result !== undefined) {
                    resolve(response.result);
                }
                else {
                    if (response.error) {
                        debugRpc(response);
                        if ((_a = response.error.data) === null || _a === void 0 ? void 0 : _a.is_panic) {
                            // if (response.error.data && response.error.data.message) {
                            const message = (_d = (_c = (_b = response.error.data) === null || _b === void 0 ? void 0 : _b.error) === null || _c === void 0 ? void 0 : _c.message) !== null && _d !== void 0 ? _d : response.error.message;
                            reject(
                            // Handle error and displays the interactive dialog to send panic error
                            new sdk_1.RustPanic(message, response.error.data.message, this.lastRequest, sdk_1.ErrorArea.LIFT_CLI, this.schemaPath));
                        }
                        else if ((_e = response.error.data) === null || _e === void 0 ? void 0 : _e.message) {
                            // Print known error code & message from engine
                            // See known errors at https://github.com/prisma/specs/tree/master/errors#prisma-sdk
                            let message = `${chalk_1.default.redBright(response.error.data.message)}\n`;
                            if ((_f = response.error.data) === null || _f === void 0 ? void 0 : _f.error_code) {
                                message =
                                    chalk_1.default.redBright(`${response.error.data.error_code}\n\n`) +
                                        message;
                                reject(new EngineError(message, response.error.data.error_code));
                            }
                            else {
                                reject(new Error(message));
                            }
                        }
                        else {
                            const text = this.persistError(request, this.messages.join('\n'));
                            reject(new Error(`${chalk_1.default.redBright('Error in RPC')}\n Request: ${JSON.stringify(request, null, 2)}\nResponse: ${JSON.stringify(response, null, 2)}\n${response.error.message}\n\n${text}\n`));
                        }
                    }
                    else {
                        reject(new Error(`Got invalid RPC response without .result property: ${JSON.stringify(response)}`));
                    }
                }
            });
            if (this.child.stdin.destroyed) {
                throw new Error(`Can't execute ${JSON.stringify(request)} because migration engine is destroyed.`);
            }
            debugRpc('SENDING RPC CALL', JSON.stringify(request));
            this.child.stdin.write(JSON.stringify(request) + '\n');
            this.lastRequest = request;
        });
    }
    persistError(request, message) {
        const filename = `failed-${request.method}-${now_1.now()}.md`;
        fs_1.default.writeFileSync(filename, `# Failed ${request.method} at ${new Date().toISOString()}
## RPC One-Liner
\`\`\`json
${JSON.stringify(request)}
\`\`\`

## RPC Input Readable
\`\`\`json
${JSON.stringify(request, null, 2)}
\`\`\`

## Stack Trace
\`\`\`bash
${message}
\`\`\`
`);
        return `Wrote ${chalk_1.default.bold(filename)} with debugging information.
Please put that file into a gist and post it in Slack.
1. ${chalk_1.default.greenBright(`cat ${filename} | pbcopy`)}
2. Create a gist ${chalk_1.default.greenBright.underline(`https://gist.github.com/new`)}`;
        // }
    }
    getRPCPayload(method, params) {
        return {
            id: messageId++,
            jsonrpc: '2.0',
            method,
            params: {
                ...params,
            },
        };
    }
}
exports.MigrateEngine = MigrateEngine;
function serializePanic(log) {
    return `${chalk_1.default.red.bold('Error in migration engine.\nReason: ')}${chalk_1.default.red(`${log.message}`)}

Please create an issue with your \`schema.prisma\` at 
${chalk_1.default.underline('https://github.com/prisma/prisma/issues/new')}\n`;
}
//# sourceMappingURL=MigrateEngine.js.map